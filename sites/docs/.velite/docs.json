[
  {
    "title": "Getting Started",
    "description": "Learn how to install and use Runed in your projects.",
    "path": "getting-started",
    "content": "<h2>Installation</h2>\n<p>Install Runed using your favorite package manager:</p>\n<pre><code class=\"language-bash\">npm install runed\n</code></pre>\n<h2>Usage</h2>\n<p>Import one of the utilities you need to either a <code>.svelte</code> or <code>.svelte.js|ts</code> file and start using\nit:</p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;component.svelte&#x22;\">&#x3C;script lang=\"ts\">\n\timport { activeElement } from \"runed\";\n\n\tlet inputElement = $state&#x3C;HTMLInputElement | undefined>();\n&#x3C;/script>\n\n&#x3C;input bind:this={inputElement} />\n\n{#if activeElement.current === inputElement}\n\tThe input element is active!\n{/if}\n</code></pre>\n<p>or</p>\n<pre><code class=\"language-ts\" metastring=\"title=&#x22;some-module.svelte.ts&#x22;\">import { activeElement } from \"runed\";\n\nfunction logActiveElement() {\n\t$effect(() => {\n\t\tconsole.log(\"Active element is \", activeElement.current);\n\t});\n}\n\nlogActiveElement();\n</code></pre>",
    "raw": "## Installation\n\nInstall Runed using your favorite package manager:\n\n```bash\nnpm install runed\n```\n\n## Usage\n\nImport one of the utilities you need to either a `.svelte` or `.svelte.js|ts` file and start using\nit:\n\n```svelte title=\"component.svelte\"\n<script lang=\"ts\">\n\timport { activeElement } from \"runed\";\n\n\tlet inputElement = $state<HTMLInputElement | undefined>();\n</script>\n\n<input bind:this={inputElement} />\n\n{#if activeElement.current === inputElement}\n\tThe input element is active!\n{/if}\n```\n\nor\n\n```ts title=\"some-module.svelte.ts\"\nimport { activeElement } from \"runed\";\n\nfunction logActiveElement() {\n\t$effect(() => {\n\t\tconsole.log(\"Active element is \", activeElement.current);\n\t});\n}\n\nlogActiveElement();\n```",
    "toc": [
      {
        "title": "Installation",
        "url": "#installation",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      }
    ],
    "category": "Anchor",
    "slug": "getting-started",
    "slugFull": "/getting-started"
  },
  {
    "title": "Introduction",
    "description": "Runes are magic, but what good is magic if you don't have a wand?",
    "path": "index",
    "content": "<p>Runed is a collection of utilities for Svelte 5 that make composing powerful applications and\nlibraries a breeze, leveraging the power of <a href=\"https://svelte.dev/blog/runes\">Svelte Runes</a>.</p>\n<h2>Why Runed?</h2>\n<p>Svelte 5 Runes unlock immense power by providing a set of primitives that allow us to build\nimpressive applications and libraries with ease. However, building complex applications often\nrequires more than just the primitives provided by Svelte Runes.</p>\n<p>Runed takes those primitives to the next level by providing:</p>\n<ul>\n<li><strong>Powerful Utilities</strong>: A set of carefully crafted utility functions and classes that simplify\ncommon tasks and reduce boilerplate.</li>\n<li><strong>Collective Efforts</strong>: We often find ourselves writing the same utility functions over and over\nagain. Runed aims to provide a single source of truth for these utilities, allowing the community\nto contribute, test, and benefit from them.</li>\n<li><strong>Consistency</strong>: A consistent set of APIs and behaviors across all utilities, so you can focus on\nbuilding your projects instead of constantly learning new APIs.</li>\n<li><strong>Reactivity First</strong>: Powered by Svelte 5's new reactivity system, Runed utilities are designed to\nhandle reactive state and side effects with ease.</li>\n<li><strong>Type Safety</strong>: Full TypeScript support to catch errors early and provide a better developer\nexperience.</li>\n</ul>\n<h2>Ideas and Principles</h2>\n<h4>Embrace the Magic of Runes</h4>\n<p>Svelte Runes are a powerful new paradigm. Runed fully embraces this concept and explores its\npotential. Our goal is to make working with Runes feel as natural and intuitive as possible.</p>\n<h4>Enhance, Don't Replace</h4>\n<p>Runed is not here to replace Svelte's core functionality, but to enhance and extend it. Our\nutilities should feel like a natural extension of Svelte, not a separate framework.</p>\n<h4>Progressive Complexity</h4>\n<p>Simple things should be simple, complex things should be possible. Runed provides easy-to-use\ndefaults while allowing for advanced customization when needed.</p>\n<h4>Open Source and Community Collaboration</h4>\n<p>Runed is an open-source, MIT licensed project that welcomes all forms of contributions from the\ncommunity. Whether it's bug reports, feature requests, or code contributions, your input will help\nmake Runed the best it can be.</p>",
    "raw": "Runed is a collection of utilities for Svelte 5 that make composing powerful applications and\nlibraries a breeze, leveraging the power of [Svelte Runes](https://svelte.dev/blog/runes).\n\n## Why Runed?\n\nSvelte 5 Runes unlock immense power by providing a set of primitives that allow us to build\nimpressive applications and libraries with ease. However, building complex applications often\nrequires more than just the primitives provided by Svelte Runes.\n\nRuned takes those primitives to the next level by providing:\n\n- **Powerful Utilities**: A set of carefully crafted utility functions and classes that simplify\n  common tasks and reduce boilerplate.\n- **Collective Efforts**: We often find ourselves writing the same utility functions over and over\n  again. Runed aims to provide a single source of truth for these utilities, allowing the community\n  to contribute, test, and benefit from them.\n- **Consistency**: A consistent set of APIs and behaviors across all utilities, so you can focus on\n  building your projects instead of constantly learning new APIs.\n- **Reactivity First**: Powered by Svelte 5's new reactivity system, Runed utilities are designed to\n  handle reactive state and side effects with ease.\n- **Type Safety**: Full TypeScript support to catch errors early and provide a better developer\n  experience.\n\n## Ideas and Principles\n\n#### Embrace the Magic of Runes\n\nSvelte Runes are a powerful new paradigm. Runed fully embraces this concept and explores its\npotential. Our goal is to make working with Runes feel as natural and intuitive as possible.\n\n#### Enhance, Don't Replace\n\nRuned is not here to replace Svelte's core functionality, but to enhance and extend it. Our\nutilities should feel like a natural extension of Svelte, not a separate framework.\n\n#### Progressive Complexity\n\nSimple things should be simple, complex things should be possible. Runed provides easy-to-use\ndefaults while allowing for advanced customization when needed.\n\n#### Open Source and Community Collaboration\n\nRuned is an open-source, MIT licensed project that welcomes all forms of contributions from the\ncommunity. Whether it's bug reports, feature requests, or code contributions, your input will help\nmake Runed the best it can be.",
    "toc": [
      {
        "title": "Why Runed?",
        "url": "#why-runed",
        "items": []
      },
      {
        "title": "Ideas and Principles",
        "url": "#ideas-and-principles",
        "items": []
      }
    ],
    "category": "Anchor",
    "slug": "index",
    "slugFull": "/index"
  },
  {
    "title": "activeElement",
    "description": "Track and access the currently focused DOM element",
    "path": "utilities/active-element",
    "content": "<script>\nimport Demo from '$lib/components/demos/active-element.svelte';\n</script>\n<p><code>activeElement</code> provides reactive access to the currently focused DOM element in your application,\nsimilar to <code>document.activeElement</code> but with reactive updates.</p>\n<ul>\n<li>Updates synchronously with DOM focus changes</li>\n<li>Returns <code>null</code> when no element is focused</li>\n<li>Safe to use with SSR (Server-Side Rendering)</li>\n<li>Lightweight alternative to manual focus tracking</li>\n<li>Searches through Shadow DOM boundaries for the true active element</li>\n</ul>\n<h2>Demo</h2>\n<demo>\n<h2>Usage</h2>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { activeElement } from \"runed\";\n&#x3C;/script>\n\n&#x3C;p>\n\tCurrently active element:\n\t{activeElement.current?.localName ?? \"No active element found\"}\n&#x3C;/p>\n</code></pre>\n<h2>Custom Document</h2>\n<p>If you wish to scope the focus tracking within a custom document or shadow root, you can pass a\n<code>DocumentOrShadowRoot</code> to the <code>ActiveElement</code> options:</p>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { ActiveElement } from \"runed\";\n\n\tconst activeElement = new ActiveElement({\n\t\tdocument: shadowRoot\n\t});\n&#x3C;/script>\n</code></pre>\n<h2>Type Definition</h2>\n<pre><code class=\"language-ts\">interface ActiveElement {\n\treadonly current: Element | null;\n}\n</code></pre></demo>",
    "raw": "<script>\nimport Demo from '$lib/components/demos/active-element.svelte';\n</script>\n\n`activeElement` provides reactive access to the currently focused DOM element in your application,\nsimilar to `document.activeElement` but with reactive updates.\n\n- Updates synchronously with DOM focus changes\n- Returns `null` when no element is focused\n- Safe to use with SSR (Server-Side Rendering)\n- Lightweight alternative to manual focus tracking\n- Searches through Shadow DOM boundaries for the true active element\n\n## Demo\n\n<Demo />\n\n## Usage\n\n```svelte\n<script lang=\"ts\">\n\timport { activeElement } from \"runed\";\n</script>\n\n<p>\n\tCurrently active element:\n\t{activeElement.current?.localName ?? \"No active element found\"}\n</p>\n```\n\n## Custom Document\n\nIf you wish to scope the focus tracking within a custom document or shadow root, you can pass a\n`DocumentOrShadowRoot` to the `ActiveElement` options:\n\n```svelte\n<script lang=\"ts\">\n\timport { ActiveElement } from \"runed\";\n\n\tconst activeElement = new ActiveElement({\n\t\tdocument: shadowRoot\n\t});\n</script>\n```\n\n## Type Definition\n\n```ts\ninterface ActiveElement {\n\treadonly current: Element | null;\n}\n```",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      },
      {
        "title": "Custom Document",
        "url": "#custom-document",
        "items": []
      },
      {
        "title": "Type Definition",
        "url": "#type-definition",
        "items": []
      }
    ],
    "category": "Elements",
    "slug": "utilities/active-element",
    "slugFull": "/utilities/active-element"
  },
  {
    "title": "AnimationFrames",
    "description": "A wrapper for requestAnimationFrame with FPS control and frame metrics",
    "path": "utilities/animation-frames",
    "content": "<script>\nimport Demo from '$lib/components/demos/animation-frames.svelte';\n</script>\n<p><code>AnimationFrames</code> provides a declarative API over the browser's\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame\"><code>requestAnimationFrame</code></a>,\noffering FPS limiting capabilities and frame metrics while handling cleanup automatically.</p>\n<h2>Demo</h2>\n<demo>\n<h2>Usage</h2>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { AnimationFrames } from \"runed\";\n\timport { Slider } from \"../ui/slider\"; // Check out shadcn-svelte!\n\n\tlet frames = $state(0);\n\tlet fpsLimit = $state(10);\n\tlet delta = $state(0);\n\tconst animation = new AnimationFrames(\n\t\t(args) => {\n\t\t\tframes++;\n\t\t\tdelta = args.delta;\n\t\t},\n\t\t{ fpsLimit: () => fpsLimit }\n\t);\n\n\tconst stats = $derived(\n\t\t`Frames: ${frames}\\nFPS: ${animation.fps.toFixed(0)}\\nDelta: ${delta.toFixed(0)}ms`\n\t);\n&#x3C;/script>\n\n&#x3C;pre>{stats}&#x3C;/pre>\n&#x3C;button onclick={toggle}>\n\t{animation.running ? \"Stop\" : \"Start\"}\n&#x3C;/button>\n&#x3C;p>\n\tFPS limit: &#x3C;b>{fpsLimit}&#x3C;/b>&#x3C;i>{fpsLimit === 0 ? \" (not limited)\" : \"\"}&#x3C;/i>\n&#x3C;/p>\n&#x3C;Slider\n\tvalue={[fpsLimit]}\n\tonValueChange={(value) => (fpsLimit = value[0] ?? 0)}\n\tmin={0}\n\tmax={144} />\n</code></pre></demo>",
    "raw": "<script>\nimport Demo from '$lib/components/demos/animation-frames.svelte';\n</script>\n\n`AnimationFrames` provides a declarative API over the browser's\n[`requestAnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame),\noffering FPS limiting capabilities and frame metrics while handling cleanup automatically.\n\n## Demo\n\n<Demo />\n\n## Usage\n\n```svelte\n<script lang=\"ts\">\n\timport { AnimationFrames } from \"runed\";\n\timport { Slider } from \"../ui/slider\"; // Check out shadcn-svelte!\n\n\tlet frames = $state(0);\n\tlet fpsLimit = $state(10);\n\tlet delta = $state(0);\n\tconst animation = new AnimationFrames(\n\t\t(args) => {\n\t\t\tframes++;\n\t\t\tdelta = args.delta;\n\t\t},\n\t\t{ fpsLimit: () => fpsLimit }\n\t);\n\n\tconst stats = $derived(\n\t\t`Frames: ${frames}\\nFPS: ${animation.fps.toFixed(0)}\\nDelta: ${delta.toFixed(0)}ms`\n\t);\n</script>\n\n<pre>{stats}</pre>\n<button onclick={toggle}>\n\t{animation.running ? \"Stop\" : \"Start\"}\n</button>\n<p>\n\tFPS limit: <b>{fpsLimit}</b><i>{fpsLimit === 0 ? \" (not limited)\" : \"\"}</i>\n</p>\n<Slider\n\tvalue={[fpsLimit]}\n\tonValueChange={(value) => (fpsLimit = value[0] ?? 0)}\n\tmin={0}\n\tmax={144} />\n```",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      }
    ],
    "category": "Animation",
    "slug": "utilities/animation-frames",
    "slugFull": "/utilities/animation-frames"
  },
  {
    "title": "Context",
    "description": "A wrapper around Svelte's Context API that provides type safety and improved ergonomics for sharing data between components.",
    "path": "utilities/context",
    "content": "<script>\n\timport { Steps, Step, Callout } from '@svecodocs/kit';\n</script>\n<p>Context allows you to pass data through the component tree without explicitly passing props through\nevery level. It's useful for sharing data that many components need, like themes, authentication\nstate, or localization preferences.</p>\n<p>The <code>Context</code> class provides a type-safe way to define, set, and retrieve context values.</p>\n<h2>Usage</h2>\n<steps>\n<p><step>Creating a Context</step></p>\n<p>First, create a <code>Context</code> instance with the type of value it will hold:</p>\n<pre><code class=\"language-ts\" metastring=\"title=&#x22;context.ts&#x22;\">import { Context } from \"runed\";\n\nexport const myTheme = new Context&#x3C;\"light\" | \"dark\">(\"theme\");\n</code></pre>\n<p>Creating a <code>Context</code> instance only defines the context - it doesn't actually set any value. The\nvalue passed to the constructor (<code>\"theme\"</code> in this example) is just an identifier used for debugging\nand error messages.</p>\n<p>Think of this step as creating a \"container\" that will later hold your context value. The container\nis typed (in this case to only accept <code>\"light\"</code> or <code>\"dark\"</code> as values) but remains empty until you\nexplicitly call <code>myTheme.set()</code> during component initialization.</p>\n<p>This separation between defining and setting context allows you to:</p>\n<ul>\n<li>Keep context definitions in separate files</li>\n<li>Reuse the same context definition across different parts of your app</li>\n<li>Maintain type safety throughout your application</li>\n<li>Set different values for the same context in different component trees</li>\n</ul>\n<p><step>Setting Context Values</step></p>\n<p>Set the context value in a parent component during initialization.</p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;+layout.svelte&#x22;\">&#x3C;script lang=\"ts\">\n\timport { myTheme } from \"./context\";\n\tlet { data, children } = $props();\n\n\tmyTheme.set(data.theme);\n&#x3C;/script>\n\n{@render children?.()}\n</code></pre>\n<callout>\n<p>Context must be set during component initialization, similar to lifecycle functions like <code>onMount</code>.\nYou cannot set context inside event handlers or callbacks.</p>\n</callout>\n<p><step>Reading Context Values</step></p>\n<p>Child components can access the context using <code>get()</code> or <code>getOr()</code></p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;+page.svelte&#x22;\">&#x3C;script lang=\"ts\">\n\timport { myTheme } from \"./context\";\n\n\tconst theme = myTheme.get();\n\t// or with a fallback value if the context is not set\n\tconst theme = myTheme.getOr(\"light\");\n&#x3C;/script>\n</code></pre>\n</steps>\n<h2>Type Definition</h2>\n<pre><code class=\"language-ts\">class Context&#x3C;TContext> {\n\t/**\n\t * @param name The name of the context.\n\t * This is used for generating the context key and error messages.\n\t */\n\tconstructor(name: string) {}\n\n\t/**\n\t * The key used to get and set the context.\n\t *\n\t * It is not recommended to use this value directly.\n\t * Instead, use the methods provided by this class.\n\t */\n\tget key(): symbol;\n\n\t/**\n\t * Checks whether this has been set in the context of a parent component.\n\t *\n\t * Must be called during component initialization.\n\t */\n\texists(): boolean;\n\n\t/**\n\t * Retrieves the context that belongs to the closest parent component.\n\t *\n\t * Must be called during component initialization.\n\t *\n\t * @throws An error if the context does not exist.\n\t */\n\tget(): TContext;\n\n\t/**\n\t * Retrieves the context that belongs to the closest parent component,\n\t * or the given fallback value if the context does not exist.\n\t *\n\t * Must be called during component initialization.\n\t */\n\tgetOr&#x3C;TFallback>(fallback: TFallback): TContext | TFallback;\n\n\t/**\n\t * Associates the given value with the current component and returns it.\n\t *\n\t * Must be called during component initialization.\n\t */\n\tset(context: TContext): TContext;\n}\n</code></pre>",
    "raw": "<script>\n\timport { Steps, Step, Callout } from '@svecodocs/kit';\n</script>\n\nContext allows you to pass data through the component tree without explicitly passing props through\nevery level. It's useful for sharing data that many components need, like themes, authentication\nstate, or localization preferences.\n\nThe `Context` class provides a type-safe way to define, set, and retrieve context values.\n\n## Usage\n\n<Steps>\n\n<Step>Creating a Context</Step>\n\nFirst, create a `Context` instance with the type of value it will hold:\n\n```ts title=\"context.ts\"\nimport { Context } from \"runed\";\n\nexport const myTheme = new Context<\"light\" | \"dark\">(\"theme\");\n```\n\nCreating a `Context` instance only defines the context - it doesn't actually set any value. The\nvalue passed to the constructor (`\"theme\"` in this example) is just an identifier used for debugging\nand error messages.\n\nThink of this step as creating a \"container\" that will later hold your context value. The container\nis typed (in this case to only accept `\"light\"` or `\"dark\"` as values) but remains empty until you\nexplicitly call `myTheme.set()` during component initialization.\n\nThis separation between defining and setting context allows you to:\n\n- Keep context definitions in separate files\n- Reuse the same context definition across different parts of your app\n- Maintain type safety throughout your application\n- Set different values for the same context in different component trees\n\n<Step>Setting Context Values</Step>\n\nSet the context value in a parent component during initialization.\n\n```svelte title=\"+layout.svelte\"\n<script lang=\"ts\">\n\timport { myTheme } from \"./context\";\n\tlet { data, children } = $props();\n\n\tmyTheme.set(data.theme);\n</script>\n\n{@render children?.()}\n```\n\n<Callout>\n\nContext must be set during component initialization, similar to lifecycle functions like `onMount`.\nYou cannot set context inside event handlers or callbacks.\n\n</Callout>\n\n<Step>Reading Context Values</Step>\n\nChild components can access the context using `get()` or `getOr()`\n\n```svelte title=\"+page.svelte\"\n<script lang=\"ts\">\n\timport { myTheme } from \"./context\";\n\n\tconst theme = myTheme.get();\n\t// or with a fallback value if the context is not set\n\tconst theme = myTheme.getOr(\"light\");\n</script>\n```\n\n</Steps>\n\n## Type Definition\n\n```ts\nclass Context<TContext> {\n\t/**\n\t * @param name The name of the context.\n\t * This is used for generating the context key and error messages.\n\t */\n\tconstructor(name: string) {}\n\n\t/**\n\t * The key used to get and set the context.\n\t *\n\t * It is not recommended to use this value directly.\n\t * Instead, use the methods provided by this class.\n\t */\n\tget key(): symbol;\n\n\t/**\n\t * Checks whether this has been set in the context of a parent component.\n\t *\n\t * Must be called during component initialization.\n\t */\n\texists(): boolean;\n\n\t/**\n\t * Retrieves the context that belongs to the closest parent component.\n\t *\n\t * Must be called during component initialization.\n\t *\n\t * @throws An error if the context does not exist.\n\t */\n\tget(): TContext;\n\n\t/**\n\t * Retrieves the context that belongs to the closest parent component,\n\t * or the given fallback value if the context does not exist.\n\t *\n\t * Must be called during component initialization.\n\t */\n\tgetOr<TFallback>(fallback: TFallback): TContext | TFallback;\n\n\t/**\n\t * Associates the given value with the current component and returns it.\n\t *\n\t * Must be called during component initialization.\n\t */\n\tset(context: TContext): TContext;\n}\n```",
    "toc": [
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      },
      {
        "title": "Type Definition",
        "url": "#type-definition",
        "items": []
      }
    ],
    "category": "State",
    "slug": "utilities/context",
    "slugFull": "/utilities/context"
  },
  {
    "title": "Debounced",
    "description": "A wrapper over `useDebounce` that returns a debounced state.",
    "path": "utilities/debounced",
    "content": "<script>\nimport Demo from '$lib/components/demos/debounced.svelte';\n</script>\n<h2>Demo</h2>\n<demo>\n<h2>Usage</h2>\n<p>This is a simple wrapper over <a href=\"https://runed.dev/docs/utilities/use-debounce\"><code>useDebounce</code></a> that\nreturns a debounced state.</p>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { Debounced } from \"runed\";\n\n\tlet search = $state(\"\");\n\tconst debounced = new Debounced(() => search, 500);\n&#x3C;/script>\n\n&#x3C;div>\n\t&#x3C;input bind:value={search} />\n\t&#x3C;p>You searched for: &#x3C;b>{debounced.current}&#x3C;/b>&#x3C;/p>\n&#x3C;/div>\n</code></pre>\n<p>You may cancel the pending update, run it immediately, or set a new value. Setting a new value\nimmediately also cancels any pending updates.</p>\n<pre><code class=\"language-ts\">let count = $state(0);\nconst debounced = new Debounced(() => count, 500);\ncount = 1;\ndebounced.cancel();\n// after a while...\nconsole.log(debounced.current); // Still 0!\n\ncount = 2;\nconsole.log(debounced.current); // Still 0!\ndebounced.setImmediately(count);\nconsole.log(debounced.current); // 2\n\ncount = 3;\nconsole.log(debounced.current); // 2\nawait debounced.updateImmediately();\nconsole.log(debounced.current); // 3\n</code></pre></demo>",
    "raw": "<script>\nimport Demo from '$lib/components/demos/debounced.svelte';\n</script>\n\n## Demo\n\n<Demo />\n\n## Usage\n\nThis is a simple wrapper over [`useDebounce`](https://runed.dev/docs/utilities/use-debounce) that\nreturns a debounced state.\n\n```svelte\n<script lang=\"ts\">\n\timport { Debounced } from \"runed\";\n\n\tlet search = $state(\"\");\n\tconst debounced = new Debounced(() => search, 500);\n</script>\n\n<div>\n\t<input bind:value={search} />\n\t<p>You searched for: <b>{debounced.current}</b></p>\n</div>\n```\n\nYou may cancel the pending update, run it immediately, or set a new value. Setting a new value\nimmediately also cancels any pending updates.\n\n```ts\nlet count = $state(0);\nconst debounced = new Debounced(() => count, 500);\ncount = 1;\ndebounced.cancel();\n// after a while...\nconsole.log(debounced.current); // Still 0!\n\ncount = 2;\nconsole.log(debounced.current); // Still 0!\ndebounced.setImmediately(count);\nconsole.log(debounced.current); // 2\n\ncount = 3;\nconsole.log(debounced.current); // 2\nawait debounced.updateImmediately();\nconsole.log(debounced.current); // 3\n```",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      }
    ],
    "category": "State",
    "slug": "utilities/debounced",
    "slugFull": "/utilities/debounced"
  },
  {
    "title": "ElementRect",
    "description": "Track element dimensions and position reactively",
    "path": "utilities/element-rect",
    "content": "<script>\n\timport Demo from '$lib/components/demos/element-rect.svelte';\n</script>\n<p><code>ElementRect</code> provides reactive access to an element's dimensions and position information,\nautomatically updating when the element's size or position changes.</p>\n<h2>Demo</h2>\n<demo>\n<h2>Usage</h2>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { ElementRect } from \"runed\";\n\n\tlet el = $state&#x3C;HTMLElement>();\n\tconst rect = new ElementRect(() => el);\n&#x3C;/script>\n\n&#x3C;textarea bind:this={el}>&#x3C;/textarea>\n\n&#x3C;p>Width: {rect.width} Height: {rect.height}&#x3C;/p>\n&#x3C;!-- alternatively -->\n&#x3C;pre>{JSON.stringify(rect.current, null, 2)}&#x3C;/pre>\n</code></pre>\n<h2>Type Definition</h2>\n<pre><code class=\"language-ts\">type Rect = Omit&#x3C;DOMRect, \"toJSON\">;\n\ninterface ElementRectOptions {\n\tinitialRect?: DOMRect;\n}\n\nclass ElementRect {\n\tconstructor(node: MaybeGetter&#x3C;HTMLElement | undefined | null>, options?: ElementRectOptions);\n\treadonly current: Rect;\n\treadonly width: number;\n\treadonly height: number;\n\treadonly top: number;\n\treadonly left: number;\n\treadonly right: number;\n\treadonly bottom: number;\n\treadonly x: number;\n\treadonly y: number;\n}\n</code></pre></demo>",
    "raw": "<script>\n\timport Demo from '$lib/components/demos/element-rect.svelte';\n</script>\n\n`ElementRect` provides reactive access to an element's dimensions and position information,\nautomatically updating when the element's size or position changes.\n\n## Demo\n\n<Demo />\n\n## Usage\n\n```svelte\n<script lang=\"ts\">\n\timport { ElementRect } from \"runed\";\n\n\tlet el = $state<HTMLElement>();\n\tconst rect = new ElementRect(() => el);\n</script>\n\n<textarea bind:this={el}></textarea>\n\n<p>Width: {rect.width} Height: {rect.height}</p>\n<!-- alternatively -->\n<pre>{JSON.stringify(rect.current, null, 2)}</pre>\n```\n\n## Type Definition\n\n```ts\ntype Rect = Omit<DOMRect, \"toJSON\">;\n\ninterface ElementRectOptions {\n\tinitialRect?: DOMRect;\n}\n\nclass ElementRect {\n\tconstructor(node: MaybeGetter<HTMLElement | undefined | null>, options?: ElementRectOptions);\n\treadonly current: Rect;\n\treadonly width: number;\n\treadonly height: number;\n\treadonly top: number;\n\treadonly left: number;\n\treadonly right: number;\n\treadonly bottom: number;\n\treadonly x: number;\n\treadonly y: number;\n}\n```",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      },
      {
        "title": "Type Definition",
        "url": "#type-definition",
        "items": []
      }
    ],
    "category": "Elements",
    "slug": "utilities/element-rect",
    "slugFull": "/utilities/element-rect"
  },
  {
    "title": "ElementSize",
    "description": "Track element dimensions reactively",
    "path": "utilities/element-size",
    "content": "<script>\n\timport Demo from '$lib/components/demos/element-size.svelte';\n</script>\n<p><code>ElementSize</code> provides reactive access to an element's width and height, automatically updating when\nthe element's dimensions change. Similar to <code>ElementRect</code> but focused only on size measurements.</p>\n<h2>Demo</h2>\n<demo>\n<h2>Usage</h2>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { ElementSize } from \"runed\";\n\n\tlet el = $state() as HTMLElement;\n\tconst size = new ElementSize(() => el);\n&#x3C;/script>\n\n&#x3C;textarea bind:this={el}>&#x3C;/textarea>\n\n&#x3C;p>Width: {size.width} Height: {size.height}&#x3C;/p>\n</code></pre>\n<h2>Type Definition</h2>\n<pre><code class=\"language-ts\">interface ElementSize {\n\treadonly width: number;\n\treadonly height: number;\n}\n</code></pre></demo>",
    "raw": "<script>\n\timport Demo from '$lib/components/demos/element-size.svelte';\n</script>\n\n`ElementSize` provides reactive access to an element's width and height, automatically updating when\nthe element's dimensions change. Similar to `ElementRect` but focused only on size measurements.\n\n## Demo\n\n<Demo />\n\n## Usage\n\n```svelte\n<script lang=\"ts\">\n\timport { ElementSize } from \"runed\";\n\n\tlet el = $state() as HTMLElement;\n\tconst size = new ElementSize(() => el);\n</script>\n\n<textarea bind:this={el}></textarea>\n\n<p>Width: {size.width} Height: {size.height}</p>\n```\n\n## Type Definition\n\n```ts\ninterface ElementSize {\n\treadonly width: number;\n\treadonly height: number;\n}\n```",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      },
      {
        "title": "Type Definition",
        "url": "#type-definition",
        "items": []
      }
    ],
    "category": "Elements",
    "slug": "utilities/element-size",
    "slugFull": "/utilities/element-size"
  },
  {
    "title": "extract",
    "description": "Resolve the value of a getter or static variable",
    "path": "utilities/extract",
    "content": "<p>In libraries like Runed, it's common to pass state reactively using getters (functions that return a\nvalue), a common pattern to pass reactivity across boundaries.</p>\n<pre><code class=\"language-ts\">// For example...\nimport { Previous } from \"runed\";\n\nlet count = $state(0);\nconst previous = new Previous(() => count);\n</code></pre>\n<p>However, some APIs accept either a reactive getter or a static value (including <code>undefined</code>):</p>\n<pre><code class=\"language-ts\">let search = $state(\"\");\nlet debounceTime = $state&#x3C;number | undefined>(500);\n\n// with a reactive value\nconst d1 = new Debounced(\n\t() => search,\n\t() => debounceTime\n);\n\n// with a static value\nconst d2 = new Debounced(() => search, 500);\n\n// no defined value\nconst d3 = new Debounced(() => search);\n</code></pre>\n<p>When writing utility functions, dealing with both types can lead to verbose and repetitive logic:</p>\n<pre><code class=\"language-ts\">setTimeout(\n    /* ... */,\n    typeof wait === \"function\" ? (wait() ?? 250) : (wait ?? 250)\n);\n</code></pre>\n<p>This is where <code>extract</code> comes in.</p>\n<h2>Usage</h2>\n<p>The <code>extract</code> utility resolves either a getter or static value to a plain value. This helps you\nwrite cleaner, safer utilities.</p>\n<pre><code class=\"language-ts\">import { extract } from \"runed\";\n\n/**\n * Triggers confetti at a given interval.\n * @param intervalProp Time between confetti bursts, in ms. Defaults to 100.\n */\nfunction throwConfetti(intervalProp?: MaybeGetter&#x3C;number | undefined>) {\n\tconst interval = $derived(extract(intervalProp, 100));\n\t// ...\n}\n</code></pre>\n<h2>Behavior</h2>\n<p>Given a <code>MaybeGetter&#x3C;T></code>, <code>extract(input, fallback)</code> resolves as follows:</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>Case</th><th>Result</th></tr></thead><tbody><tr><td><code>input</code> is a value</td><td>Returns the value</td></tr><tr><td><code>input</code> is <code>undefined</code></td><td>Returns the fallback</td></tr><tr><td><code>input</code> is a function returning a value</td><td>Returns the function result</td></tr><tr><td><code>input</code> is a function returning <code>undefined</code></td><td>Returns the fallback</td></tr></tbody></table>\n<p>The fallback is <em>optional</em>. If you omit it, <code>extract()</code> returns <code>T | undefined</code>.</p>\n<h2>Types</h2>\n<pre><code class=\"language-ts\">function extract&#x3C;T>(input: MaybeGetter&#x3C;T | undefined>, fallback: T): T;\nfunction extract&#x3C;T>(input: MaybeGetter&#x3C;T | undefined>): T | undefined;\n</code></pre>",
    "raw": "In libraries like Runed, it's common to pass state reactively using getters (functions that return a\nvalue), a common pattern to pass reactivity across boundaries.\n\n```ts\n// For example...\nimport { Previous } from \"runed\";\n\nlet count = $state(0);\nconst previous = new Previous(() => count);\n```\n\nHowever, some APIs accept either a reactive getter or a static value (including `undefined`):\n\n```ts\nlet search = $state(\"\");\nlet debounceTime = $state<number | undefined>(500);\n\n// with a reactive value\nconst d1 = new Debounced(\n\t() => search,\n\t() => debounceTime\n);\n\n// with a static value\nconst d2 = new Debounced(() => search, 500);\n\n// no defined value\nconst d3 = new Debounced(() => search);\n```\n\nWhen writing utility functions, dealing with both types can lead to verbose and repetitive logic:\n\n```ts\nsetTimeout(\n    /* ... */,\n    typeof wait === \"function\" ? (wait() ?? 250) : (wait ?? 250)\n);\n```\n\nThis is where `extract` comes in.\n\n## Usage\n\nThe `extract` utility resolves either a getter or static value to a plain value. This helps you\nwrite cleaner, safer utilities.\n\n```ts\nimport { extract } from \"runed\";\n\n/**\n * Triggers confetti at a given interval.\n * @param intervalProp Time between confetti bursts, in ms. Defaults to 100.\n */\nfunction throwConfetti(intervalProp?: MaybeGetter<number | undefined>) {\n\tconst interval = $derived(extract(intervalProp, 100));\n\t// ...\n}\n```\n\n## Behavior\n\nGiven a `MaybeGetter<T>`, `extract(input, fallback)` resolves as follows:\n\n| Case                                        | Result                      |\n| ------------------------------------------- | --------------------------- |\n| `input` is a value                          | Returns the value           |\n| `input` is `undefined`                      | Returns the fallback        |\n| `input` is a function returning a value     | Returns the function result |\n| `input` is a function returning `undefined` | Returns the fallback        |\n\nThe fallback is _optional_. If you omit it, `extract()` returns `T | undefined`.\n\n## Types\n\n```ts\nfunction extract<T>(input: MaybeGetter<T | undefined>, fallback: T): T;\nfunction extract<T>(input: MaybeGetter<T | undefined>): T | undefined;\n```",
    "toc": [
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      },
      {
        "title": "Behavior",
        "url": "#behavior",
        "items": []
      },
      {
        "title": "Types",
        "url": "#types",
        "items": []
      }
    ],
    "category": "Reactivity",
    "slug": "utilities/extract",
    "slugFull": "/utilities/extract"
  },
  {
    "title": "FiniteStateMachine",
    "description": "Defines a strongly-typed finite state machine.",
    "path": "utilities/finite-state-machine",
    "content": "<script>\n\timport Demo from '$lib/components/demos/finite-state-machine.svelte';\n</script>\n<h2>Demo</h2>\n<demo>\n<pre><code class=\"language-ts\">type MyStates = \"disabled\" | \"idle\" | \"running\";\ntype MyEvents = \"toggleEnabled\" | \"start\" | \"stop\";\nconst f = new FiniteStateMachine&#x3C;MyStates, MyEvents>(\"disabled\", {\n\tdisabled: {\n\t\ttoggleEnabled: \"idle\"\n\t},\n\tidle: {\n\t\ttoggleEnabled: \"disabled\",\n\t\tstart: \"running\"\n\t},\n\trunning: {\n\t\t_enter: () => {\n\t\t\tf.debounce(2000, \"stop\");\n\t\t},\n\t\tstop: \"idle\",\n\t\ttoggleEnabled: \"disabled\"\n\t}\n});\n</code></pre>\n<h2>Usage</h2>\n<p>Finite state machines (often abbreviated as \"FSMs\") are useful for tracking and manipulating\nsomething that could be in one of many different states. It centralizes the definition of every\npossible <em>state</em> and the <em>events</em> that might trigger a transition from one state to another. Here is\na state machine describing a simple toggle switch:</p>\n<pre><code class=\"language-ts\">import { FiniteStateMachine } from \"runed\";\ntype MyStates = \"on\" | \"off\";\ntype MyEvents = \"toggle\";\n\nconst f = new FiniteStateMachine&#x3C;MyStates, MyEvents>(\"off\", {\n\toff: {\n\t\ttoggle: \"on\"\n\t},\n\ton: {\n\t\ttoggle: \"off\"\n\t}\n});\n</code></pre>\n<p>The first argument to the <code>FiniteStateMachine</code> constructor is the initial state. The second argument\nis an object with one key for each state. Each state then describes which events are valid for that\nstate, and which state that event should lead to.</p>\n<p>In the above example of a simple switch, there are two states (<code>on</code> and <code>off</code>). The <code>toggle</code> event\nin either state leads to the other state.</p>\n<p>You send events to the FSM using <code>f.send</code>. To send the <code>toggle</code> event, invoke <code>f.send('toggle')</code>.</p>\n<h3>Actions</h3>\n<p>Maybe you want fancier logic for an event handler, or you want to conditionally transition into\nanother state. Instead of strings, you can use <em>actions</em>.</p>\n<p>An action is a function that returns a state. An action can receive parameters, and it can use those\nparameters to dynamically choose which state should come next. It can also prevent a state\ntransition by returning nothing.</p>\n<pre><code class=\"language-ts\">type MyStates = \"on\" | \"off\" | \"cooldown\";\n\nconst f = new FiniteStateMachine&#x3C;MyStates, MyEvents>(\"off\", {\n\toff: {\n\t\ttoggle: () => {\n\t\t\tif (isTuesday) {\n\t\t\t\t// Switch can only turn on during Tuesdays\n\t\t\t\treturn \"on\";\n\t\t\t}\n\t\t\t// All other days, nothing is returned and state is unchanged.\n\t\t}\n\t},\n\ton: {\n\t\ttoggle: (heldMillis: number) => {\n\t\t\t// You can also dynamically return the next state!\n\t\t\t// Only turn off if switch is depressed for 3 seconds\n\t\t\tif (heldMillis > 3000) {\n\t\t\t\treturn \"off\";\n\t\t\t}\n\t\t}\n\t}\n});\n</code></pre>\n<h3>Lifecycle methods</h3>\n<p>You can define special handlers that are invoked whenever a state is entered or exited:</p>\n<pre><code class=\"language-ts\">const f = new FiniteStateMachine&#x3C;MyStates, MyEvents>('off', {\n\toff: {\n\t\ttoggle: 'on'\n\t\t_enter: (meta) => { console.log('switch is off') }\n\t\t_exit: (meta) => { console.log('switch is no longer off') }\n\t},\n\ton: {\n\t\ttoggle: 'off'\n\t\t_enter: (meta) => { console.log('switch is on') }\n\t\t_exit: (meta) => { console.log('switch is no longer on') }\n\t}\n});\n</code></pre>\n<p>The lifecycle methods are invoked with a metadata object containing some useful information:</p>\n<ul>\n<li><code>from</code>: the name of the event that is being exited</li>\n<li><code>to</code>: the name of the event that is being entered</li>\n<li><code>event</code>: the name of the event which has triggered the transition</li>\n<li><code>args</code>: (optional) you may pass additional metadata when invoking an action with\n<code>f.send('theAction', additional, params, as, args)</code></li>\n</ul>\n<p>The <code>_enter</code> handler for the initial state is called upon creation of the FSM. It is invoked with\nboth the <code>from</code> and <code>event</code> fields set to <code>null</code>.</p>\n<h3>Wildcard handlers</h3>\n<p>There is one special state used as a fallback: <code>*</code>. If you have the fallback state, and you attempt\nto <code>send()</code> an event that is not handled by the current state, then it will try to find a handler\nfor that event on the <code>*</code> state before discarding the event:</p>\n<pre><code class=\"language-ts\">const f = new FiniteStateMachine&#x3C;MyStates, MyEvents>('off', {\n\toff: {\n\t\ttoggle: 'on'\n\t},\n\ton: {\n\t\ttoggle: 'off'\n\t}\n\t'*': {\n\t\temergency: 'off'\n\t}\n});\n\n// will always result in the switch turning off.\nf.send('emergency');\n</code></pre>\n<h3>Debouncing</h3>\n<p>Frequently, you want to transition to another state after some time has elapsed. To do this, use the\n<code>debounce</code> method:</p>\n<pre><code class=\"language-ts\">f.send(\"toggle\"); // turn on immediately\nf.debounce(5000, \"toggle\"); // turn off in 5000 milliseconds\n</code></pre>\n<p>If you re-invoke debounce with the same event, it will cancel the existing timer and start the\ncountdown over:</p>\n<pre><code class=\"language-ts\">// schedule a toggle in five seconds\nf.debounce(5000, \"toggle\");\n// ... less than 5000ms elapses ...\nf.debounce(5000, \"toggle\");\n// The second call cancels the original timer, and starts a new one\n</code></pre>\n<p>You can also use <code>debounce</code> in both actions and lifecycle methods. In both of the following\nexamples, the lightswitch will turn itself off five seconds after it was turned on:</p>\n<pre><code class=\"language-ts\">const f = new FiniteStateMachine&#x3C;MyStates, MyEvents>(\"off\", {\n\toff: {\n\t\ttoggle: () => {\n\t\t\tf.debounce(5000, \"toggle\");\n\t\t\treturn \"on\";\n\t\t}\n\t},\n\ton: {\n\t\ttoggle: \"off\"\n\t}\n});\n</code></pre>\n<pre><code class=\"language-ts\">const f = new FiniteStateMachine&#x3C;MyStates, MyEvents>(\"off\", {\n\toff: {\n\t\ttoggle: \"on\"\n\t},\n\ton: {\n\t\ttoggle: \"off\",\n\t\t_enter: () => {\n\t\t\tf.debounce(5000, \"toggle\");\n\t\t}\n\t}\n});\n</code></pre>\n<h2>Notes</h2>\n<p><code>FiniteStateMachine</code> is a loving rewrite of\n<a href=\"https://github.com/kenkunz/svelte-fsm\">kenkunz/svelte-fsm</a>.</p>\n<p>FSMs are ideal for representing many different kinds of systems and interaction patterns.\n<code>FiniteStateMachine</code> is an intentionally minimalistic implementation. If you're looking for a more\npowerful FSM library, <a href=\"https://github.com/statelyai/xstate\">statelyai/xstate</a> is an excellent\nlibrary with more features — and a steeper learning curve.</p></demo>",
    "raw": "<script>\n\timport Demo from '$lib/components/demos/finite-state-machine.svelte';\n</script>\n\n## Demo\n\n<Demo />\n\n```ts\ntype MyStates = \"disabled\" | \"idle\" | \"running\";\ntype MyEvents = \"toggleEnabled\" | \"start\" | \"stop\";\nconst f = new FiniteStateMachine<MyStates, MyEvents>(\"disabled\", {\n\tdisabled: {\n\t\ttoggleEnabled: \"idle\"\n\t},\n\tidle: {\n\t\ttoggleEnabled: \"disabled\",\n\t\tstart: \"running\"\n\t},\n\trunning: {\n\t\t_enter: () => {\n\t\t\tf.debounce(2000, \"stop\");\n\t\t},\n\t\tstop: \"idle\",\n\t\ttoggleEnabled: \"disabled\"\n\t}\n});\n```\n\n## Usage\n\nFinite state machines (often abbreviated as \"FSMs\") are useful for tracking and manipulating\nsomething that could be in one of many different states. It centralizes the definition of every\npossible _state_ and the _events_ that might trigger a transition from one state to another. Here is\na state machine describing a simple toggle switch:\n\n```ts\nimport { FiniteStateMachine } from \"runed\";\ntype MyStates = \"on\" | \"off\";\ntype MyEvents = \"toggle\";\n\nconst f = new FiniteStateMachine<MyStates, MyEvents>(\"off\", {\n\toff: {\n\t\ttoggle: \"on\"\n\t},\n\ton: {\n\t\ttoggle: \"off\"\n\t}\n});\n```\n\nThe first argument to the `FiniteStateMachine` constructor is the initial state. The second argument\nis an object with one key for each state. Each state then describes which events are valid for that\nstate, and which state that event should lead to.\n\nIn the above example of a simple switch, there are two states (`on` and `off`). The `toggle` event\nin either state leads to the other state.\n\nYou send events to the FSM using `f.send`. To send the `toggle` event, invoke `f.send('toggle')`.\n\n### Actions\n\nMaybe you want fancier logic for an event handler, or you want to conditionally transition into\nanother state. Instead of strings, you can use _actions_.\n\nAn action is a function that returns a state. An action can receive parameters, and it can use those\nparameters to dynamically choose which state should come next. It can also prevent a state\ntransition by returning nothing.\n\n```ts\ntype MyStates = \"on\" | \"off\" | \"cooldown\";\n\nconst f = new FiniteStateMachine<MyStates, MyEvents>(\"off\", {\n\toff: {\n\t\ttoggle: () => {\n\t\t\tif (isTuesday) {\n\t\t\t\t// Switch can only turn on during Tuesdays\n\t\t\t\treturn \"on\";\n\t\t\t}\n\t\t\t// All other days, nothing is returned and state is unchanged.\n\t\t}\n\t},\n\ton: {\n\t\ttoggle: (heldMillis: number) => {\n\t\t\t// You can also dynamically return the next state!\n\t\t\t// Only turn off if switch is depressed for 3 seconds\n\t\t\tif (heldMillis > 3000) {\n\t\t\t\treturn \"off\";\n\t\t\t}\n\t\t}\n\t}\n});\n```\n\n### Lifecycle methods\n\nYou can define special handlers that are invoked whenever a state is entered or exited:\n\n```ts\nconst f = new FiniteStateMachine<MyStates, MyEvents>('off', {\n\toff: {\n\t\ttoggle: 'on'\n\t\t_enter: (meta) => { console.log('switch is off') }\n\t\t_exit: (meta) => { console.log('switch is no longer off') }\n\t},\n\ton: {\n\t\ttoggle: 'off'\n\t\t_enter: (meta) => { console.log('switch is on') }\n\t\t_exit: (meta) => { console.log('switch is no longer on') }\n\t}\n});\n```\n\nThe lifecycle methods are invoked with a metadata object containing some useful information:\n\n- `from`: the name of the event that is being exited\n- `to`: the name of the event that is being entered\n- `event`: the name of the event which has triggered the transition\n- `args`: (optional) you may pass additional metadata when invoking an action with\n  `f.send('theAction', additional, params, as, args)`\n\nThe `_enter` handler for the initial state is called upon creation of the FSM. It is invoked with\nboth the `from` and `event` fields set to `null`.\n\n### Wildcard handlers\n\nThere is one special state used as a fallback: `*`. If you have the fallback state, and you attempt\nto `send()` an event that is not handled by the current state, then it will try to find a handler\nfor that event on the `*` state before discarding the event:\n\n```ts\nconst f = new FiniteStateMachine<MyStates, MyEvents>('off', {\n\toff: {\n\t\ttoggle: 'on'\n\t},\n\ton: {\n\t\ttoggle: 'off'\n\t}\n\t'*': {\n\t\temergency: 'off'\n\t}\n});\n\n// will always result in the switch turning off.\nf.send('emergency');\n```\n\n### Debouncing\n\nFrequently, you want to transition to another state after some time has elapsed. To do this, use the\n`debounce` method:\n\n```ts\nf.send(\"toggle\"); // turn on immediately\nf.debounce(5000, \"toggle\"); // turn off in 5000 milliseconds\n```\n\nIf you re-invoke debounce with the same event, it will cancel the existing timer and start the\ncountdown over:\n\n```ts\n// schedule a toggle in five seconds\nf.debounce(5000, \"toggle\");\n// ... less than 5000ms elapses ...\nf.debounce(5000, \"toggle\");\n// The second call cancels the original timer, and starts a new one\n```\n\nYou can also use `debounce` in both actions and lifecycle methods. In both of the following\nexamples, the lightswitch will turn itself off five seconds after it was turned on:\n\n```ts\nconst f = new FiniteStateMachine<MyStates, MyEvents>(\"off\", {\n\toff: {\n\t\ttoggle: () => {\n\t\t\tf.debounce(5000, \"toggle\");\n\t\t\treturn \"on\";\n\t\t}\n\t},\n\ton: {\n\t\ttoggle: \"off\"\n\t}\n});\n```\n\n```ts\nconst f = new FiniteStateMachine<MyStates, MyEvents>(\"off\", {\n\toff: {\n\t\ttoggle: \"on\"\n\t},\n\ton: {\n\t\ttoggle: \"off\",\n\t\t_enter: () => {\n\t\t\tf.debounce(5000, \"toggle\");\n\t\t}\n\t}\n});\n```\n\n## Notes\n\n`FiniteStateMachine` is a loving rewrite of\n[kenkunz/svelte-fsm](https://github.com/kenkunz/svelte-fsm).\n\nFSMs are ideal for representing many different kinds of systems and interaction patterns.\n`FiniteStateMachine` is an intentionally minimalistic implementation. If you're looking for a more\npowerful FSM library, [statelyai/xstate](https://github.com/statelyai/xstate) is an excellent\nlibrary with more features&thinsp;—&thinsp;and a steeper learning curve.",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": [
          {
            "title": "Actions",
            "url": "#actions",
            "items": []
          },
          {
            "title": "Lifecycle methods",
            "url": "#lifecycle-methods",
            "items": []
          },
          {
            "title": "Wildcard handlers",
            "url": "#wildcard-handlers",
            "items": []
          },
          {
            "title": "Debouncing",
            "url": "#debouncing",
            "items": []
          }
        ]
      },
      {
        "title": "Notes",
        "url": "#notes",
        "items": []
      }
    ],
    "category": "State",
    "slug": "utilities/finite-state-machine",
    "slugFull": "/utilities/finite-state-machine"
  },
  {
    "title": "IsFocusWithin",
    "description": "A utility that tracks whether any descendant element has focus within a specified container element.",
    "path": "utilities/is-focus-within",
    "content": "<script>\nimport Demo from '$lib/components/demos/is-focus-within.svelte';\n</script>\n<p><code>IsFocusWithin</code> reactively tracks focus state within a container element, updating automatically\nwhen focus changes.</p>\n<h2>Demo</h2>\n<demo>\n<h2>Usage</h2>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { IsFocusWithin } from \"runed\";\n\n\tlet formElement = $state&#x3C;HTMLFormElement>();\n\tconst focusWithinForm = new IsFocusWithin(() => formElement);\n&#x3C;/script>\n\n&#x3C;p>Focus within form: {focusWithinForm.current}&#x3C;/p>\n&#x3C;form bind:this={formElement}>\n\t&#x3C;input type=\"text\" />\n\t&#x3C;button type=\"submit\">Submit&#x3C;/button>\n&#x3C;/form>\n</code></pre>\n<h2>Type Definition</h2>\n<pre><code class=\"language-ts\">class IsFocusWithin {\n\tconstructor(node: MaybeGetter&#x3C;HTMLElement | undefined | null>);\n\treadonly current: boolean;\n}\n</code></pre></demo>",
    "raw": "<script>\nimport Demo from '$lib/components/demos/is-focus-within.svelte';\n</script>\n\n`IsFocusWithin` reactively tracks focus state within a container element, updating automatically\nwhen focus changes.\n\n## Demo\n\n<Demo />\n\n## Usage\n\n```svelte\n<script lang=\"ts\">\n\timport { IsFocusWithin } from \"runed\";\n\n\tlet formElement = $state<HTMLFormElement>();\n\tconst focusWithinForm = new IsFocusWithin(() => formElement);\n</script>\n\n<p>Focus within form: {focusWithinForm.current}</p>\n<form bind:this={formElement}>\n\t<input type=\"text\" />\n\t<button type=\"submit\">Submit</button>\n</form>\n```\n\n## Type Definition\n\n```ts\nclass IsFocusWithin {\n\tconstructor(node: MaybeGetter<HTMLElement | undefined | null>);\n\treadonly current: boolean;\n}\n```",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      },
      {
        "title": "Type Definition",
        "url": "#type-definition",
        "items": []
      }
    ],
    "category": "Elements",
    "slug": "utilities/is-focus-within",
    "slugFull": "/utilities/is-focus-within"
  },
  {
    "title": "IsIdle",
    "description": "Track if a user is idle and the last time they were active.",
    "path": "utilities/is-idle",
    "content": "<script>\nimport Demo from '$lib/components/demos/is-idle.svelte';\n</script>\n<p><code>IsIdle</code> tracks user activity and determines if they're idle based on a configurable timeout. It\nmonitors mouse movement, keyboard input, and touch events to detect user interaction.</p>\n<h2>Demo</h2>\n<demo>\n<h2>Usage</h2>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { AnimationFrames, IsIdle } from \"runed\";\n\n\tconst idle = new IsIdle({ timeout: 1000 });\n&#x3C;/script>\n\n&#x3C;p>Idle: {idle.current}&#x3C;/p>\n&#x3C;p>\n\tLast active: {new Date(idle.lastActive).toLocaleTimeString()}\n&#x3C;/p>\n</code></pre>\n<h2>Type Definitions</h2>\n<pre><code class=\"language-ts\">interface IsIdleOptions {\n\t/**\n\t * The events that should set the idle state to `true`\n\t *\n\t * @default ['mousemove', 'mousedown', 'resize', 'keydown', 'touchstart', 'wheel']\n\t */\n\tevents?: MaybeGetter&#x3C;(keyof WindowEventMap)[]>;\n\t/**\n\t * The timeout in milliseconds before the idle state is set to `true`. Defaults to 60 seconds.\n\t *\n\t * @default 60000\n\t */\n\ttimeout?: MaybeGetter&#x3C;number>;\n\t/**\n\t * Detect document visibility changes\n\t *\n\t * @default false\n\t */\n\tdetectVisibilityChanges?: MaybeGetter&#x3C;boolean>;\n\t/**\n\t * The initial state of the idle property\n\t *\n\t * @default false\n\t */\n\tinitialState?: boolean;\n}\n\nclass IsIdle {\n\tconstructor(options?: IsIdleOptions);\n\treadonly current: boolean;\n\treadonly lastActive: number;\n}\n</code></pre></demo>",
    "raw": "<script>\nimport Demo from '$lib/components/demos/is-idle.svelte';\n</script>\n\n`IsIdle` tracks user activity and determines if they're idle based on a configurable timeout. It\nmonitors mouse movement, keyboard input, and touch events to detect user interaction.\n\n## Demo\n\n<Demo />\n\n## Usage\n\n```svelte\n<script lang=\"ts\">\n\timport { AnimationFrames, IsIdle } from \"runed\";\n\n\tconst idle = new IsIdle({ timeout: 1000 });\n</script>\n\n<p>Idle: {idle.current}</p>\n<p>\n\tLast active: {new Date(idle.lastActive).toLocaleTimeString()}\n</p>\n```\n\n## Type Definitions\n\n```ts\ninterface IsIdleOptions {\n\t/**\n\t * The events that should set the idle state to `true`\n\t *\n\t * @default ['mousemove', 'mousedown', 'resize', 'keydown', 'touchstart', 'wheel']\n\t */\n\tevents?: MaybeGetter<(keyof WindowEventMap)[]>;\n\t/**\n\t * The timeout in milliseconds before the idle state is set to `true`. Defaults to 60 seconds.\n\t *\n\t * @default 60000\n\t */\n\ttimeout?: MaybeGetter<number>;\n\t/**\n\t * Detect document visibility changes\n\t *\n\t * @default false\n\t */\n\tdetectVisibilityChanges?: MaybeGetter<boolean>;\n\t/**\n\t * The initial state of the idle property\n\t *\n\t * @default false\n\t */\n\tinitialState?: boolean;\n}\n\nclass IsIdle {\n\tconstructor(options?: IsIdleOptions);\n\treadonly current: boolean;\n\treadonly lastActive: number;\n}\n```",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      },
      {
        "title": "Type Definitions",
        "url": "#type-definitions",
        "items": []
      }
    ],
    "category": "Sensors",
    "slug": "utilities/is-idle",
    "slugFull": "/utilities/is-idle"
  },
  {
    "title": "IsInViewport",
    "description": "Track if an element is visible within the current viewport.",
    "path": "utilities/is-in-viewport",
    "content": "<script>\nimport Demo from '$lib/components/demos/is-in-viewport.svelte';\n</script>\n<p><code>IsInViewport</code> uses the <a href=\"/docs/utilities/use-intersection-observer\"><code>useIntersectionObserver</code></a>\nutility to track if an element is visible within the current viewport.</p>\n<p>It accepts an element or getter that returns an element and an optional <code>options</code> object that aligns\nwith the <a href=\"/docs/utilities/use-intersection-observer\"><code>useIntersectionObserver</code></a> utility options.</p>\n<h2>Demo</h2>\n<demo>\n<h2>Usage</h2>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { IsInViewport } from \"runed\";\n\n\tlet targetNode = $state&#x3C;HTMLElement>()!;\n\tconst inViewport = new IsInViewport(() => targetNode);\n&#x3C;/script>\n\n&#x3C;p bind:this={targetNode}>Target node&#x3C;/p>\n\n&#x3C;p>Target node in viewport: {inViewport.current}&#x3C;/p>\n</code></pre>\n<h2>Type Definition</h2>\n<pre><code class=\"language-ts\">import { type UseIntersectionObserverOptions } from \"runed\";\nexport type IsInViewportOptions = UseIntersectionObserverOptions;\n\nexport declare class IsInViewport {\n\tconstructor(node: MaybeGetter&#x3C;HTMLElement | null | undefined>, options?: IsInViewportOptions);\n\tget current(): boolean;\n}\n</code></pre>\n<div class=\"h-[500px]\"></div></demo>",
    "raw": "<script>\nimport Demo from '$lib/components/demos/is-in-viewport.svelte';\n</script>\n\n`IsInViewport` uses the [`useIntersectionObserver`](/docs/utilities/use-intersection-observer)\nutility to track if an element is visible within the current viewport.\n\nIt accepts an element or getter that returns an element and an optional `options` object that aligns\nwith the [`useIntersectionObserver`](/docs/utilities/use-intersection-observer) utility options.\n\n## Demo\n\n<Demo />\n\n## Usage\n\n```svelte\n<script lang=\"ts\">\n\timport { IsInViewport } from \"runed\";\n\n\tlet targetNode = $state<HTMLElement>()!;\n\tconst inViewport = new IsInViewport(() => targetNode);\n</script>\n\n<p bind:this={targetNode}>Target node</p>\n\n<p>Target node in viewport: {inViewport.current}</p>\n```\n\n## Type Definition\n\n```ts\nimport { type UseIntersectionObserverOptions } from \"runed\";\nexport type IsInViewportOptions = UseIntersectionObserverOptions;\n\nexport declare class IsInViewport {\n\tconstructor(node: MaybeGetter<HTMLElement | null | undefined>, options?: IsInViewportOptions);\n\tget current(): boolean;\n}\n```\n\n<!-- Ensure the page can scroll so the target can be outside of the viewport -->\n<div class=\"h-[500px]\"></div>",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      },
      {
        "title": "Type Definition",
        "url": "#type-definition",
        "items": []
      }
    ],
    "category": "Elements",
    "slug": "utilities/is-in-viewport",
    "slugFull": "/utilities/is-in-viewport"
  },
  {
    "title": "IsMounted",
    "description": "A class that returns the mounted state of the component it's called in.",
    "path": "utilities/is-mounted",
    "content": "<script>\nimport Demo from '$lib/components/demos/is-mounted.svelte';\n</script>\n<h2>Demo</h2>\n<demo>\n<h2>Usage</h2>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { IsMounted } from \"runed\";\n\n\tconst isMounted = new IsMounted();\n&#x3C;/script>\n</code></pre>\n<p>Which is a shorthand for one of the following:</p>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { onMount } from \"svelte\";\n\n\tconst isMounted = $state({ current: false });\n\n\tonMount(() => {\n\t\tisMounted.current = true;\n\t});\n&#x3C;/script>\n</code></pre>\n<p>or</p>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { untrack } from \"svelte\";\n\n\tconst isMounted = $state({ current: false });\n\n\t$effect(() => {\n\t\tuntrack(() => (isMounted.current = true));\n\t});\n&#x3C;/script>\n</code></pre></demo>",
    "raw": "<script>\nimport Demo from '$lib/components/demos/is-mounted.svelte';\n</script>\n\n## Demo\n\n<Demo />\n\n## Usage\n\n```svelte\n<script lang=\"ts\">\n\timport { IsMounted } from \"runed\";\n\n\tconst isMounted = new IsMounted();\n</script>\n```\n\nWhich is a shorthand for one of the following:\n\n```svelte\n<script lang=\"ts\">\n\timport { onMount } from \"svelte\";\n\n\tconst isMounted = $state({ current: false });\n\n\tonMount(() => {\n\t\tisMounted.current = true;\n\t});\n</script>\n```\n\nor\n\n```svelte\n<script lang=\"ts\">\n\timport { untrack } from \"svelte\";\n\n\tconst isMounted = $state({ current: false });\n\n\t$effect(() => {\n\t\tuntrack(() => (isMounted.current = true));\n\t});\n</script>\n```",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      }
    ],
    "category": "Component",
    "slug": "utilities/is-mounted",
    "slugFull": "/utilities/is-mounted"
  },
  {
    "title": "onClickOutside",
    "description": "Handle clicks outside of a specified element.",
    "path": "utilities/on-click-outside",
    "content": "<script>\nimport Demo from '$lib/components/demos/on-click-outside.svelte';\nimport DemoDialog from '$lib/components/demos/on-click-outside-dialog.svelte';\nimport { PropField } from '@svecodocs/kit'\n</script>\n<p><code>onClickOutside</code> detects clicks that occur outside a specified element's boundaries and executes a\ncallback function. It's commonly used for dismissible dropdowns, modals, and other interactive\ncomponents.</p>\n<h2>Demo</h2>\n<demo>\n<h2>Basic Usage</h2>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { onClickOutside } from \"runed\";\n\n\tlet container = $state&#x3C;HTMLElement>()!;\n\n\tonClickOutside(\n\t\t() => container,\n\t\t() => console.log(\"clicked outside\")\n\t);\n&#x3C;/script>\n\n&#x3C;div bind:this={container}>\n\t&#x3C;!-- Container content -->\n&#x3C;/div>\n&#x3C;button>I'm outside the container&#x3C;/button>\n</code></pre>\n<h2>Advanced Usage</h2>\n<h3>Controlled Listener</h3>\n<p>The function returns control methods to programmatically manage the listener, <code>start</code> and <code>stop</code> and\na reactive read-only property <code>enabled</code> to check the current status of the listeners.</p>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { onClickOutside } from \"runed\";\n\n\tlet dialog = $state&#x3C;HTMLDialogElement>()!;\n\n\tconst clickOutside = onClickOutside(\n\t\t() => dialog,\n\t\t() => {\n\t\t\tdialog.close();\n\t\t\tclickOutside.stop();\n\t\t},\n\t\t{ immediate: false }\n\t);\n\n\tfunction openDialog() {\n\t\tdialog.showModal();\n\t\tclickOutside.start();\n\t}\n\n\tfunction closeDialog() {\n\t\tdialog.close();\n\t\tclickOutside.stop();\n\t}\n&#x3C;/script>\n\n&#x3C;button onclick={openDialog}>Open Dialog&#x3C;/button>\n&#x3C;dialog bind:this={dialog}>\n\t&#x3C;div>\n\t\t&#x3C;button onclick={closeDialog}>Close Dialog&#x3C;/button>\n\t&#x3C;/div>\n&#x3C;/dialog>\n</code></pre>\n<p>Here's an example of using <code>onClickOutside</code> with a <code>&#x3C;dialog></code>:</p>\n<demodialog>\n<h2>Options</h2>\n<propfield name=\"immediate\" type=\"boolean\" defaultvalue=\"true\">\n<p>Whether the click outside handler is enabled by default or not. If set to <code>false</code>, the handler will\nnot be active until enabled by calling the returned <code>start</code> function.</p>\n</propfield>\n<propfield name=\"detectIframe\" type=\"boolean\" defaultvalue=\"false\">\n<p>Controls whether focus events from iframes trigger the callback. Since iframe click events don't\nbubble to the parent document, you may want to enable this if you need to detect when users interact\nwith iframe content.</p>\n</propfield>\n<propfield name=\"document\" type=\"Document\" defaultvalue=\"document\">\n<p>The document object to use, defaults to the global document.</p>\n</propfield>\n<propfield name=\"window\" type=\"Window\" defaultvalue=\"window\">\n<p>The window object to use, defaults to the global window.</p>\n</propfield>\n<h2>Type Definitions</h2>\n<pre><code class=\"language-ts\">export type OnClickOutsideOptions = ConfigurableWindow &#x26;\n\tConfigurableDocument &#x26; {\n\t\t/**\n\t\t * Whether the click outside handler is enabled by default or not.\n\t\t * If set to false, the handler will not be active until enabled by\n\t\t * calling the returned `start` function\n\t\t *\n\t\t * @default true\n\t\t */\n\t\timmediate?: boolean;\n\t\t/**\n\t\t * Controls whether focus events from iframes trigger the callback.\n\t\t *\n\t\t * Since iframe click events don't bubble to the parent document,\n\t\t * you may want to enable this if you need to detect when users\n\t\t * interact with iframe content.\n\t\t *\n\t\t * @default false\n\t\t */\n\t\tdetectIframe?: boolean;\n\t};\n/**\n * A utility that calls a given callback when a click event occurs outside of\n * a specified container element.\n *\n * @template T - The type of the container element, defaults to HTMLElement.\n * @param {MaybeElementGetter&#x3C;T>} container - The container element or a getter function that returns the container element.\n * @param {() => void} callback - The callback function to call when a click event occurs outside of the container.\n * @param {OnClickOutsideOptions} [opts={}] - Optional configuration object.\n * @param {ConfigurableDocument} [opts.document=defaultDocument] - The document object to use, defaults to the global document.\n * @param {boolean} [opts.immediate=true] - Whether the click outside handler is enabled by default or not.\n * @param {boolean} [opts.detectIframe=false] - Controls whether focus events from iframes trigger the callback.\n *\n * @see {@link https://runed.dev/docs/utilities/on-click-outside}\n */\nexport declare function onClickOutside&#x3C;T extends Element = HTMLElement>(\n\tcontainer: MaybeElementGetter&#x3C;T>,\n\tcallback: (event: PointerEvent | FocusEvent) => void,\n\topts?: OnClickOutsideOptions\n): {\n\t/** Stop listening for click events outside the container. */\n\tstop: () => boolean;\n\t/** Start listening for click events outside the container. */\n\tstart: () => boolean;\n\t/** Whether the click outside handler is currently enabled or not. */\n\treadonly enabled: boolean;\n};\n</code></pre></demodialog></demo>",
    "raw": "<script>\nimport Demo from '$lib/components/demos/on-click-outside.svelte';\nimport DemoDialog from '$lib/components/demos/on-click-outside-dialog.svelte';\nimport { PropField } from '@svecodocs/kit'\n</script>\n\n`onClickOutside` detects clicks that occur outside a specified element's boundaries and executes a\ncallback function. It's commonly used for dismissible dropdowns, modals, and other interactive\ncomponents.\n\n## Demo\n\n<Demo />\n\n## Basic Usage\n\n```svelte\n<script lang=\"ts\">\n\timport { onClickOutside } from \"runed\";\n\n\tlet container = $state<HTMLElement>()!;\n\n\tonClickOutside(\n\t\t() => container,\n\t\t() => console.log(\"clicked outside\")\n\t);\n</script>\n\n<div bind:this={container}>\n\t<!-- Container content -->\n</div>\n<button>I'm outside the container</button>\n```\n\n## Advanced Usage\n\n### Controlled Listener\n\nThe function returns control methods to programmatically manage the listener, `start` and `stop` and\na reactive read-only property `enabled` to check the current status of the listeners.\n\n```svelte\n<script lang=\"ts\">\n\timport { onClickOutside } from \"runed\";\n\n\tlet dialog = $state<HTMLDialogElement>()!;\n\n\tconst clickOutside = onClickOutside(\n\t\t() => dialog,\n\t\t() => {\n\t\t\tdialog.close();\n\t\t\tclickOutside.stop();\n\t\t},\n\t\t{ immediate: false }\n\t);\n\n\tfunction openDialog() {\n\t\tdialog.showModal();\n\t\tclickOutside.start();\n\t}\n\n\tfunction closeDialog() {\n\t\tdialog.close();\n\t\tclickOutside.stop();\n\t}\n</script>\n\n<button onclick={openDialog}>Open Dialog</button>\n<dialog bind:this={dialog}>\n\t<div>\n\t\t<button onclick={closeDialog}>Close Dialog</button>\n\t</div>\n</dialog>\n```\n\nHere's an example of using `onClickOutside` with a `<dialog>`:\n\n<DemoDialog />\n\n## Options\n\n<PropField name=\"immediate\" type=\"boolean\" defaultValue=\"true\">\n\nWhether the click outside handler is enabled by default or not. If set to `false`, the handler will\nnot be active until enabled by calling the returned `start` function.\n\n</PropField>\n\n<PropField name=\"detectIframe\" type=\"boolean\" defaultValue=\"false\">\n\nControls whether focus events from iframes trigger the callback. Since iframe click events don't\nbubble to the parent document, you may want to enable this if you need to detect when users interact\nwith iframe content.\n\n</PropField>\n\n<PropField name=\"document\" type=\"Document\" defaultValue=\"document\">\n\nThe document object to use, defaults to the global document.\n\n</PropField>\n\n<PropField name=\"window\" type=\"Window\" defaultValue=\"window\">\n\nThe window object to use, defaults to the global window.\n\n</PropField>\n\n## Type Definitions\n\n```ts\nexport type OnClickOutsideOptions = ConfigurableWindow &\n\tConfigurableDocument & {\n\t\t/**\n\t\t * Whether the click outside handler is enabled by default or not.\n\t\t * If set to false, the handler will not be active until enabled by\n\t\t * calling the returned `start` function\n\t\t *\n\t\t * @default true\n\t\t */\n\t\timmediate?: boolean;\n\t\t/**\n\t\t * Controls whether focus events from iframes trigger the callback.\n\t\t *\n\t\t * Since iframe click events don't bubble to the parent document,\n\t\t * you may want to enable this if you need to detect when users\n\t\t * interact with iframe content.\n\t\t *\n\t\t * @default false\n\t\t */\n\t\tdetectIframe?: boolean;\n\t};\n/**\n * A utility that calls a given callback when a click event occurs outside of\n * a specified container element.\n *\n * @template T - The type of the container element, defaults to HTMLElement.\n * @param {MaybeElementGetter<T>} container - The container element or a getter function that returns the container element.\n * @param {() => void} callback - The callback function to call when a click event occurs outside of the container.\n * @param {OnClickOutsideOptions} [opts={}] - Optional configuration object.\n * @param {ConfigurableDocument} [opts.document=defaultDocument] - The document object to use, defaults to the global document.\n * @param {boolean} [opts.immediate=true] - Whether the click outside handler is enabled by default or not.\n * @param {boolean} [opts.detectIframe=false] - Controls whether focus events from iframes trigger the callback.\n *\n * @see {@link https://runed.dev/docs/utilities/on-click-outside}\n */\nexport declare function onClickOutside<T extends Element = HTMLElement>(\n\tcontainer: MaybeElementGetter<T>,\n\tcallback: (event: PointerEvent | FocusEvent) => void,\n\topts?: OnClickOutsideOptions\n): {\n\t/** Stop listening for click events outside the container. */\n\tstop: () => boolean;\n\t/** Start listening for click events outside the container. */\n\tstart: () => boolean;\n\t/** Whether the click outside handler is currently enabled or not. */\n\treadonly enabled: boolean;\n};\n```",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Basic Usage",
        "url": "#basic-usage",
        "items": []
      },
      {
        "title": "Advanced Usage",
        "url": "#advanced-usage",
        "items": [
          {
            "title": "Controlled Listener",
            "url": "#controlled-listener",
            "items": []
          }
        ]
      },
      {
        "title": "Options",
        "url": "#options",
        "items": []
      },
      {
        "title": "Type Definitions",
        "url": "#type-definitions",
        "items": []
      }
    ],
    "category": "Sensors",
    "slug": "utilities/on-click-outside",
    "slugFull": "/utilities/on-click-outside"
  },
  {
    "title": "PersistedState",
    "description": "A reactive state manager that persists and synchronizes state across browser sessions and tabs using Web Storage APIs.",
    "path": "utilities/persisted-state",
    "content": "<script>\nimport Demo from '$lib/components/demos/persisted-state.svelte';\nimport { Callout } from '@svecodocs/kit'\n</script>\n<p><code>PersistedState</code> provides a reactive state container that automatically persists data to browser\nstorage and optionally synchronizes changes across browser tabs in real-time.</p>\n<h2>Demo</h2>\n<demo>\n<callout>\n\tYou can refresh this page and/or open it in another tab to see the count state being persisted\n\tand synchronized across sessions and tabs.\n</callout>\n<h2>Usage</h2>\n<p>Initialize <code>PersistedState</code> by providing a unique key and an initial value for the state.</p>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { PersistedState } from \"runed\";\n\n\tconst count = new PersistedState(\"count\", 0);\n&#x3C;/script>\n\n&#x3C;div>\n\t&#x3C;button onclick={() => count.current++}>Increment&#x3C;/button>\n\t&#x3C;button onclick={() => count.current--}>Decrement&#x3C;/button>\n\t&#x3C;button onclick={() => (count.current = 0)}>Reset&#x3C;/button>\n\t&#x3C;p>Count: {count.current}&#x3C;/p>\n&#x3C;/div>\n</code></pre>\n<h2>Configuration Options</h2>\n<p><code>PersistedState</code> includes an <code>options</code> object that allows you to customize the behavior of the state\nmanager.</p>\n<pre><code class=\"language-ts\">const state = new PersistedState(\"user-preferences\", initialValue, {\n\t// Use sessionStorage instead of localStorage (default: 'local')\n\tstorage: \"session\",\n\n\t// Disable cross-tab synchronization (default: true)\n\tsyncTabs: false,\n\n\t// Custom serialization handlers\n\tserializer: {\n\t\tserialize: superjson.stringify,\n\t\tdeserialize: superjson.parse\n\t}\n});\n</code></pre>\n<h3>Storage Options</h3>\n<ul>\n<li><code>'local'</code>: Data persists until explicitly cleared</li>\n<li><code>'session'</code>: Data persists until the browser session ends</li>\n</ul>\n<h3>Cross-Tab Synchronization</h3>\n<p>When <code>syncTabs</code> is enabled (default), changes are automatically synchronized across all browser tabs\nusing the storage event.</p>\n<h3>Custom Serialization</h3>\n<p>Provide custom <code>serialize</code> and <code>deserialize</code> functions to handle complex data types:</p>\n<pre><code class=\"language-ts\">import superjson from \"superjson\";\n\n// Example with Date objects\nconst lastAccessed = new PersistedState(\"last-accessed\", new Date(), {\n\tserializer: {\n\t\tserialize: superjson.stringify,\n\t\tdeserialize: superjson.parse\n\t}\n});\n</code></pre></demo>",
    "raw": "<script>\nimport Demo from '$lib/components/demos/persisted-state.svelte';\nimport { Callout } from '@svecodocs/kit'\n</script>\n\n`PersistedState` provides a reactive state container that automatically persists data to browser\nstorage and optionally synchronizes changes across browser tabs in real-time.\n\n## Demo\n\n<Demo />\n<Callout>\n\tYou can refresh this page and/or open it in another tab to see the count state being persisted\n\tand synchronized across sessions and tabs.\n</Callout>\n\n## Usage\n\nInitialize `PersistedState` by providing a unique key and an initial value for the state.\n\n```svelte\n<script lang=\"ts\">\n\timport { PersistedState } from \"runed\";\n\n\tconst count = new PersistedState(\"count\", 0);\n</script>\n\n<div>\n\t<button onclick={() => count.current++}>Increment</button>\n\t<button onclick={() => count.current--}>Decrement</button>\n\t<button onclick={() => (count.current = 0)}>Reset</button>\n\t<p>Count: {count.current}</p>\n</div>\n```\n\n## Configuration Options\n\n`PersistedState` includes an `options` object that allows you to customize the behavior of the state\nmanager.\n\n```ts\nconst state = new PersistedState(\"user-preferences\", initialValue, {\n\t// Use sessionStorage instead of localStorage (default: 'local')\n\tstorage: \"session\",\n\n\t// Disable cross-tab synchronization (default: true)\n\tsyncTabs: false,\n\n\t// Custom serialization handlers\n\tserializer: {\n\t\tserialize: superjson.stringify,\n\t\tdeserialize: superjson.parse\n\t}\n});\n```\n\n### Storage Options\n\n- `'local'`: Data persists until explicitly cleared\n- `'session'`: Data persists until the browser session ends\n\n### Cross-Tab Synchronization\n\nWhen `syncTabs` is enabled (default), changes are automatically synchronized across all browser tabs\nusing the storage event.\n\n### Custom Serialization\n\nProvide custom `serialize` and `deserialize` functions to handle complex data types:\n\n```ts\nimport superjson from \"superjson\";\n\n// Example with Date objects\nconst lastAccessed = new PersistedState(\"last-accessed\", new Date(), {\n\tserializer: {\n\t\tserialize: superjson.stringify,\n\t\tdeserialize: superjson.parse\n\t}\n});\n```",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      },
      {
        "title": "Configuration Options",
        "url": "#configuration-options",
        "items": [
          {
            "title": "Storage Options",
            "url": "#storage-options",
            "items": []
          },
          {
            "title": "Cross-Tab Synchronization",
            "url": "#cross-tab-synchronization",
            "items": []
          },
          {
            "title": "Custom Serialization",
            "url": "#custom-serialization",
            "items": []
          }
        ]
      }
    ],
    "category": "State",
    "slug": "utilities/persisted-state",
    "slugFull": "/utilities/persisted-state"
  },
  {
    "title": "PressedKeys",
    "description": "Tracks which keys are currently pressed",
    "path": "utilities/pressed-keys",
    "content": "<script>\nimport Demo from '$lib/components/demos/pressed-keys.svelte';\n</script>\n<h2>Demo</h2>\n<demo>\n<h2>Usage</h2>\n<p>With an instance of <code>PressedKeys</code>, you can use the <code>has</code> method.</p>\n<pre><code class=\"language-ts\">const keys = new PressedKeys();\n\nconst isArrowDownPressed = $derived(keys.has(\"ArrowDown\"));\nconst isCtrlAPressed = $derived(keys.has(\"Control\", \"a\"));\n</code></pre>\n<p>Or get all of the currently pressed keys:</p>\n<pre><code class=\"language-ts\">const keys = new PressedKeys();\nconsole.log(keys.all);\n</code></pre>\n<p>Or register a callback to execute when specified key combination is pressed:</p>\n<pre><code class=\"language-ts\">const keys = new PressedKeys();\nkeys.onKeys([\"meta\", \"k\"], () => {\n\tconsole.log(\"open command palette\");\n});\n</code></pre></demo>",
    "raw": "<script>\nimport Demo from '$lib/components/demos/pressed-keys.svelte';\n</script>\n\n## Demo\n\n<Demo />\n\n## Usage\n\nWith an instance of `PressedKeys`, you can use the `has` method.\n\n```ts\nconst keys = new PressedKeys();\n\nconst isArrowDownPressed = $derived(keys.has(\"ArrowDown\"));\nconst isCtrlAPressed = $derived(keys.has(\"Control\", \"a\"));\n```\n\nOr get all of the currently pressed keys:\n\n```ts\nconst keys = new PressedKeys();\nconsole.log(keys.all);\n```\n\nOr register a callback to execute when specified key combination is pressed:\n\n```ts\nconst keys = new PressedKeys();\nkeys.onKeys([\"meta\", \"k\"], () => {\n\tconsole.log(\"open command palette\");\n});\n```",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      }
    ],
    "category": "Sensors",
    "slug": "utilities/pressed-keys",
    "slugFull": "/utilities/pressed-keys"
  },
  {
    "title": "Previous",
    "description": "A utility that tracks and provides access to the previous value of a reactive getter.",
    "path": "utilities/previous",
    "content": "<script>\nimport Demo from '$lib/components/demos/previous.svelte';\n</script>\n<p>The <code>Previous</code> utility creates a reactive wrapper that maintains the previous value of a getter\nfunction. This is particularly useful when you need to compare state changes or implement transition\neffects.</p>\n<h2>Demo</h2>\n<demo>\n<h2>Usage</h2>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { Previous } from \"runed\";\n\n\tlet count = $state(0);\n\tconst previous = new Previous(() => count);\n&#x3C;/script>\n\n&#x3C;div>\n\t&#x3C;button onclick={() => count++}>Count: {count}&#x3C;/button>\n\t&#x3C;pre>Previous: {`${previous.current}`}&#x3C;/pre>\n&#x3C;/div>\n</code></pre>\n<h2>Type Definition</h2>\n<pre><code class=\"language-ts\">class Previous&#x3C;T> {\n\tconstructor(getter: () => T);\n\n\treadonly current: T | undefined; // Previous value\n}\n</code></pre></demo>",
    "raw": "<script>\nimport Demo from '$lib/components/demos/previous.svelte';\n</script>\n\nThe `Previous` utility creates a reactive wrapper that maintains the previous value of a getter\nfunction. This is particularly useful when you need to compare state changes or implement transition\neffects.\n\n## Demo\n\n<Demo />\n\n## Usage\n\n```svelte\n<script lang=\"ts\">\n\timport { Previous } from \"runed\";\n\n\tlet count = $state(0);\n\tconst previous = new Previous(() => count);\n</script>\n\n<div>\n\t<button onclick={() => count++}>Count: {count}</button>\n\t<pre>Previous: {`${previous.current}`}</pre>\n</div>\n```\n\n## Type Definition\n\n```ts\nclass Previous<T> {\n\tconstructor(getter: () => T);\n\n\treadonly current: T | undefined; // Previous value\n}\n```",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      },
      {
        "title": "Type Definition",
        "url": "#type-definition",
        "items": []
      }
    ],
    "category": "State",
    "slug": "utilities/previous",
    "slugFull": "/utilities/previous"
  },
  {
    "title": "resource",
    "description": "Watch for changes and runs async data fetching",
    "path": "utilities/resource",
    "content": "<script>\nimport Demo from '$lib/components/demos/resource.svelte';\nimport { Callout } from '@svecodocs/kit'\n</script>\n<p>In SvelteKit, using load functions is the primary approach for data fetching. While you can handle\nreactive data fetching by using <code>URLSearchParams</code> for query parameters, there are cases where you\nmight need more flexibility at the component level.</p>\n<p>This is where <code>resource</code> comes in - it's a utility that seamlessly combines reactive state\nmanagement with async data fetching.</p>\n<p>Built on top of <code>watch</code>, it runs after rendering by default, but also provides a pre-render option\nvia <code>resource.pre()</code>.</p>\n<h2>Demo</h2>\n<demo>\n<h2>Usage</h2>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { resource } from \"runed\";\n\n\tlet id = $state(1);\n\n\tconst searchResource = resource(\n\t\t() => id,\n\t\tasync (id, prevId, { data, refetching, onCleanup, signal }) => {\n\t\t\t// data: the previous value returned from the fetcher\n\n\t\t\t// refetching: whether the fetcher is currently refetching\n\t\t\t// or it can be the value you passed to refetch()\n\n\t\t\t// onCleanup: A cleanup function that will be called when the source is invalidated\n\t\t\t// and the fetcher is about to re-run\n\n\t\t\t// signal: AbortSignal for cancelling fetch requests\n\t\t\tconst response = await fetch(`api/posts?id=${id}`, { signal });\n\t\t\treturn response.json();\n\t\t},\n\t\t{\n\t\t\tdebounce: 300\n\t\t\t// lazy: Skip initial fetch when true\n\t\t\t// once: Only fetch once when true\n\t\t\t// initialValue: Provides an initial value for the resource\n\t\t\t// debounce: Debounce rapid changes\n\t\t\t// throttle: Throttle rapid changes\n\t\t}\n\t);\n\n\t// The current value of the resource\n\tsearchResource.current;\n\t// Whether the resource is currently loading\n\tsearchResource.loading;\n\t// Error if the fetch failed\n\tsearchResource.error;\n\t// Update the resource value directly, useful for optimistic updates\n\tsearchResource.mutate();\n\t// Re-run the fetcher with current watching values\n\tsearchResource.refetch();\n&#x3C;/script>\n\n&#x3C;input type=\"number\" bind:value={id} />\n\n{#if searchResults.loading}\n\t&#x3C;div>Loading...&#x3C;/div>\n{:else if searchResults.error}\n\t&#x3C;div>Error: {searchResults.error.message}&#x3C;/div>\n{:else}\n\t&#x3C;ul>\n\t\t{#each searchResults.current ?? [] as result}\n\t\t\t&#x3C;li>{result.title}&#x3C;/li>\n\t\t{/each}\n\t&#x3C;/ul>\n{/if}\n</code></pre>\n<h2>Features</h2>\n<ul>\n<li><strong>Automatic Request Cancellation</strong>: When dependencies change, in-flight requests are automatically\ncanceled</li>\n<li><strong>Loading &#x26; Error States</strong>: Built-in states for loading and error handling</li>\n<li><strong>Debouncing &#x26; Throttling</strong>: Optional debounce and throttle options for rate limiting</li>\n<li><strong>Type Safety</strong>: Full TypeScript support with inferred types</li>\n<li><strong>Multiple Dependencies</strong>: Support for tracking multiple reactive dependencies</li>\n<li><strong>Custom Cleanup</strong>: Register cleanup functions that run before refetching</li>\n<li><strong>Pre-render Support</strong>: <code>resource.pre()</code> for pre-render execution</li>\n</ul>\n<h2>Advanced Usage</h2>\n<h3>Multiple Dependencies</h3>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\tconst results = resource([() => query, () => page], async ([query, page]) => {\n\t\tconst res = await fetch(`/api/search?q=${query}&#x26;page=${page}`);\n\t\treturn res.json();\n\t});\n&#x3C;/script>\n</code></pre>\n<h3>Custom Cleanup</h3>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\tconst stream = resource(\n\t\t() => streamId,\n\t\tasync (id, _, { signal, onCleanup }) => {\n\t\t\tconst eventSource = new EventSource(`/api/stream/${id}`);\n\t\t\tonCleanup(() => eventSource.close());\n\n\t\t\tconst res = await fetch(`/api/stream/${id}/init`, { signal });\n\t\t\treturn res.json();\n\t\t}\n\t);\n&#x3C;/script>\n</code></pre>\n<h3>Pre-render Execution</h3>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\tconst data = resource.pre(\n\t\t() => query,\n\t\tasync (query) => {\n\t\t\tconst res = await fetch(`/api/search?q=${query}`);\n\t\t\treturn res.json();\n\t\t}\n\t);\n&#x3C;/script>\n</code></pre>\n<h2>Configuration Options</h2>\n<h3><code>lazy</code></h3>\n<p>When true, skips the initial fetch. The resource will only fetch when dependencies change or\n<code>refetch()</code> is called.</p>\n<h3><code>once</code></h3>\n<p>When true, only fetches once. Subsequent dependency changes won't trigger new fetches.</p>\n<h3><code>initialValue</code></h3>\n<p>Provides an initial value for the resource before the first fetch completes. Useful if you already\nhave the data and don't want to wait for the fetch to complete.</p>\n<h3><code>debounce</code></h3>\n<p>Time in milliseconds to debounce rapid changes. Useful for search inputs.</p>\n<p>The debounce implementation will cancel pending requests and only execute the last one after the\nspecified delay.</p>\n<h3><code>throttle</code></h3>\n<p>Time in milliseconds to throttle rapid changes. Useful for real-time updates.</p>\n<p>The throttle implementation will ensure that requests are spaced at least by the specified delay,\nreturning the pending promise if called too soon.</p>\n<callout>\nNote that you should use either debounce or throttle, not both - if both are specified, debounce takes precedence.\n</callout>\n<h2>Type Definitions</h2>\n<pre><code class=\"language-ts\">type ResourceOptions&#x3C;Data> = {\n\t/** Skip initial fetch when true */\n\tlazy?: boolean;\n\t/** Only fetch once when true */\n\tonce?: boolean;\n\t/** Initial value for the resource */\n\tinitialValue?: Data;\n\t/** Debounce time in milliseconds */\n\tdebounce?: number;\n\t/** Throttle time in milliseconds */\n\tthrottle?: number;\n};\n\ntype ResourceState&#x3C;Data> = {\n\t/** Current value of the resource */\n\tcurrent: Data | undefined;\n\t/** Whether the resource is currently loading */\n\tloading: boolean;\n\t/** Error if the fetch failed */\n\terror: Error | undefined;\n};\n\ntype ResourceReturn&#x3C;Data, RefetchInfo = unknown> = ResourceState&#x3C;Data> &#x26; {\n\t/** Update the resource value directly */\n\tmutate: (value: Data) => void;\n\t/** Re-run the fetcher with current values */\n\trefetch: (info?: RefetchInfo) => Promise&#x3C;Data | undefined>;\n};\n\ntype ResourceFetcherRefetchInfo&#x3C;Data, RefetchInfo = unknown> = {\n\t/** Previous data return from fetcher */\n\tdata: Data | undefined;\n\t/** Whether the fetcher is currently refetching or it can be the value you passed to refetch. */\n\trefetching: RefetchInfo | boolean;\n\t/** A cleanup function that will be called when the source is invalidated and the fetcher is about to re-run */\n\tonCleanup: (fn: () => void) => void;\n\t/** AbortSignal for cancelling fetch requests */\n\tsignal: AbortSignal;\n};\n\ntype ResourceFetcher&#x3C;Source, Data, RefetchInfo = unknown> = (\n\t/** Current value of the source */\n\tvalue: Source extends Array&#x3C;unknown>\n\t\t? {\n\t\t\t\t[K in keyof Source]: Source[K];\n\t\t\t}\n\t\t: Source,\n\t/** Previous value of the source */\n\tpreviousValue: Source extends Array&#x3C;unknown>\n\t\t? {\n\t\t\t\t[K in keyof Source]: Source[K];\n\t\t\t}\n\t\t: Source | undefined,\n\tinfo: ResourceFetcherRefetchInfo&#x3C;Data, RefetchInfo>\n) => Promise&#x3C;Data>;\n\nfunction resource&#x3C;\n\tSource,\n\tRefetchInfo = unknown,\n\tFetcher extends ResourceFetcher&#x3C;\n\t\tSource,\n\t\tAwaited&#x3C;ReturnType&#x3C;Fetcher>>,\n\t\tRefetchInfo\n\t> = ResourceFetcher&#x3C;Source, any, RefetchInfo>\n>(\n\tsource: Getter&#x3C;Source>,\n\tfetcher: Fetcher,\n\toptions?: ResourceOptions&#x3C;Awaited&#x3C;ReturnType&#x3C;Fetcher>>>\n): ResourceReturn&#x3C;Awaited&#x3C;ReturnType&#x3C;Fetcher>>, RefetchInfo>;\n</code></pre></demo>",
    "raw": "<script>\nimport Demo from '$lib/components/demos/resource.svelte';\nimport { Callout } from '@svecodocs/kit'\n</script>\n\nIn SvelteKit, using load functions is the primary approach for data fetching. While you can handle\nreactive data fetching by using `URLSearchParams` for query parameters, there are cases where you\nmight need more flexibility at the component level.\n\nThis is where `resource` comes in - it's a utility that seamlessly combines reactive state\nmanagement with async data fetching.\n\nBuilt on top of `watch`, it runs after rendering by default, but also provides a pre-render option\nvia `resource.pre()`.\n\n## Demo\n\n<Demo />\n\n## Usage\n\n```svelte\n<script lang=\"ts\">\n\timport { resource } from \"runed\";\n\n\tlet id = $state(1);\n\n\tconst searchResource = resource(\n\t\t() => id,\n\t\tasync (id, prevId, { data, refetching, onCleanup, signal }) => {\n\t\t\t// data: the previous value returned from the fetcher\n\n\t\t\t// refetching: whether the fetcher is currently refetching\n\t\t\t// or it can be the value you passed to refetch()\n\n\t\t\t// onCleanup: A cleanup function that will be called when the source is invalidated\n\t\t\t// and the fetcher is about to re-run\n\n\t\t\t// signal: AbortSignal for cancelling fetch requests\n\t\t\tconst response = await fetch(`api/posts?id=${id}`, { signal });\n\t\t\treturn response.json();\n\t\t},\n\t\t{\n\t\t\tdebounce: 300\n\t\t\t// lazy: Skip initial fetch when true\n\t\t\t// once: Only fetch once when true\n\t\t\t// initialValue: Provides an initial value for the resource\n\t\t\t// debounce: Debounce rapid changes\n\t\t\t// throttle: Throttle rapid changes\n\t\t}\n\t);\n\n\t// The current value of the resource\n\tsearchResource.current;\n\t// Whether the resource is currently loading\n\tsearchResource.loading;\n\t// Error if the fetch failed\n\tsearchResource.error;\n\t// Update the resource value directly, useful for optimistic updates\n\tsearchResource.mutate();\n\t// Re-run the fetcher with current watching values\n\tsearchResource.refetch();\n</script>\n\n<input type=\"number\" bind:value={id} />\n\n{#if searchResults.loading}\n\t<div>Loading...</div>\n{:else if searchResults.error}\n\t<div>Error: {searchResults.error.message}</div>\n{:else}\n\t<ul>\n\t\t{#each searchResults.current ?? [] as result}\n\t\t\t<li>{result.title}</li>\n\t\t{/each}\n\t</ul>\n{/if}\n```\n\n## Features\n\n- **Automatic Request Cancellation**: When dependencies change, in-flight requests are automatically\n  canceled\n- **Loading & Error States**: Built-in states for loading and error handling\n- **Debouncing & Throttling**: Optional debounce and throttle options for rate limiting\n- **Type Safety**: Full TypeScript support with inferred types\n- **Multiple Dependencies**: Support for tracking multiple reactive dependencies\n- **Custom Cleanup**: Register cleanup functions that run before refetching\n- **Pre-render Support**: `resource.pre()` for pre-render execution\n\n## Advanced Usage\n\n### Multiple Dependencies\n\n```svelte\n<script lang=\"ts\">\n\tconst results = resource([() => query, () => page], async ([query, page]) => {\n\t\tconst res = await fetch(`/api/search?q=${query}&page=${page}`);\n\t\treturn res.json();\n\t});\n</script>\n```\n\n### Custom Cleanup\n\n```svelte\n<script lang=\"ts\">\n\tconst stream = resource(\n\t\t() => streamId,\n\t\tasync (id, _, { signal, onCleanup }) => {\n\t\t\tconst eventSource = new EventSource(`/api/stream/${id}`);\n\t\t\tonCleanup(() => eventSource.close());\n\n\t\t\tconst res = await fetch(`/api/stream/${id}/init`, { signal });\n\t\t\treturn res.json();\n\t\t}\n\t);\n</script>\n```\n\n### Pre-render Execution\n\n```svelte\n<script lang=\"ts\">\n\tconst data = resource.pre(\n\t\t() => query,\n\t\tasync (query) => {\n\t\t\tconst res = await fetch(`/api/search?q=${query}`);\n\t\t\treturn res.json();\n\t\t}\n\t);\n</script>\n```\n\n## Configuration Options\n\n### `lazy`\n\nWhen true, skips the initial fetch. The resource will only fetch when dependencies change or\n`refetch()` is called.\n\n### `once`\n\nWhen true, only fetches once. Subsequent dependency changes won't trigger new fetches.\n\n### `initialValue`\n\nProvides an initial value for the resource before the first fetch completes. Useful if you already\nhave the data and don't want to wait for the fetch to complete.\n\n### `debounce`\n\nTime in milliseconds to debounce rapid changes. Useful for search inputs.\n\nThe debounce implementation will cancel pending requests and only execute the last one after the\nspecified delay.\n\n### `throttle`\n\nTime in milliseconds to throttle rapid changes. Useful for real-time updates.\n\nThe throttle implementation will ensure that requests are spaced at least by the specified delay,\nreturning the pending promise if called too soon.\n\n<Callout>\nNote that you should use either debounce or throttle, not both - if both are specified, debounce takes precedence.\n</Callout>\n\n## Type Definitions\n\n```ts\ntype ResourceOptions<Data> = {\n\t/** Skip initial fetch when true */\n\tlazy?: boolean;\n\t/** Only fetch once when true */\n\tonce?: boolean;\n\t/** Initial value for the resource */\n\tinitialValue?: Data;\n\t/** Debounce time in milliseconds */\n\tdebounce?: number;\n\t/** Throttle time in milliseconds */\n\tthrottle?: number;\n};\n\ntype ResourceState<Data> = {\n\t/** Current value of the resource */\n\tcurrent: Data | undefined;\n\t/** Whether the resource is currently loading */\n\tloading: boolean;\n\t/** Error if the fetch failed */\n\terror: Error | undefined;\n};\n\ntype ResourceReturn<Data, RefetchInfo = unknown> = ResourceState<Data> & {\n\t/** Update the resource value directly */\n\tmutate: (value: Data) => void;\n\t/** Re-run the fetcher with current values */\n\trefetch: (info?: RefetchInfo) => Promise<Data | undefined>;\n};\n\ntype ResourceFetcherRefetchInfo<Data, RefetchInfo = unknown> = {\n\t/** Previous data return from fetcher */\n\tdata: Data | undefined;\n\t/** Whether the fetcher is currently refetching or it can be the value you passed to refetch. */\n\trefetching: RefetchInfo | boolean;\n\t/** A cleanup function that will be called when the source is invalidated and the fetcher is about to re-run */\n\tonCleanup: (fn: () => void) => void;\n\t/** AbortSignal for cancelling fetch requests */\n\tsignal: AbortSignal;\n};\n\ntype ResourceFetcher<Source, Data, RefetchInfo = unknown> = (\n\t/** Current value of the source */\n\tvalue: Source extends Array<unknown>\n\t\t? {\n\t\t\t\t[K in keyof Source]: Source[K];\n\t\t\t}\n\t\t: Source,\n\t/** Previous value of the source */\n\tpreviousValue: Source extends Array<unknown>\n\t\t? {\n\t\t\t\t[K in keyof Source]: Source[K];\n\t\t\t}\n\t\t: Source | undefined,\n\tinfo: ResourceFetcherRefetchInfo<Data, RefetchInfo>\n) => Promise<Data>;\n\nfunction resource<\n\tSource,\n\tRefetchInfo = unknown,\n\tFetcher extends ResourceFetcher<\n\t\tSource,\n\t\tAwaited<ReturnType<Fetcher>>,\n\t\tRefetchInfo\n\t> = ResourceFetcher<Source, any, RefetchInfo>\n>(\n\tsource: Getter<Source>,\n\tfetcher: Fetcher,\n\toptions?: ResourceOptions<Awaited<ReturnType<Fetcher>>>\n): ResourceReturn<Awaited<ReturnType<Fetcher>>, RefetchInfo>;\n```",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      },
      {
        "title": "Features",
        "url": "#features",
        "items": []
      },
      {
        "title": "Advanced Usage",
        "url": "#advanced-usage",
        "items": [
          {
            "title": "Multiple Dependencies",
            "url": "#multiple-dependencies",
            "items": []
          },
          {
            "title": "Custom Cleanup",
            "url": "#custom-cleanup",
            "items": []
          },
          {
            "title": "Pre-render Execution",
            "url": "#pre-render-execution",
            "items": []
          }
        ]
      },
      {
        "title": "Configuration Options",
        "url": "#configuration-options",
        "items": [
          {
            "title": "lazy",
            "url": "#lazy",
            "items": []
          },
          {
            "title": "once",
            "url": "#once",
            "items": []
          },
          {
            "title": "initialValue",
            "url": "#initialvalue",
            "items": []
          },
          {
            "title": "debounce",
            "url": "#debounce",
            "items": []
          },
          {
            "title": "throttle",
            "url": "#throttle",
            "items": []
          }
        ]
      },
      {
        "title": "Type Definitions",
        "url": "#type-definitions",
        "items": []
      }
    ],
    "category": "Reactivity",
    "slug": "utilities/resource",
    "slugFull": "/utilities/resource"
  },
  {
    "title": "ScrollState",
    "description": "Track scroll position, direction, and edge states with support for programmatic scrolling.",
    "path": "utilities/scroll-state",
    "content": "<script>\nimport Demo from '$lib/components/demos/scroll-state.svelte';\n</script>\n<h2>Demo</h2>\n<demo>\n<h2>Overview</h2>\n<p><code>ScrollState</code> is a reactive utility that lets you:</p>\n<ul>\n<li>Track scroll positions (<code>x</code> / <code>y</code>)</li>\n<li>Detect scroll direction (<code>left</code>, <code>right</code>, <code>top</code>, <code>bottom</code>)</li>\n<li>Determine if the user has scrolled to an edge (<code>arrived</code> state)</li>\n<li>Perform programmatic scrolling (<code>scrollTo</code>, <code>scrollToTop</code>, <code>scrollToBottom</code>)</li>\n<li>Listen to scroll and scroll-end events</li>\n<li>Respect flex, RTL, and reverse layout modes</li>\n</ul>\n<p>Inspired by <a href=\"https://vueuse.org/useScroll\">VueUse's <code>useScroll</code></a>, this utility is built for Svelte\nand works with DOM elements, the <code>window</code>, or <code>document</code>.</p>\n<h2>Usage</h2>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { ScrollState } from \"runed\";\n\n\tlet el = $state&#x3C;HTMLElement>();\n\n\tconst scroll = new ScrollState({\n\t\telement: () => el\n\t});\n&#x3C;/script>\n\n&#x3C;div bind:this={el} style=\"overflow: auto; height: 200px;\">\n\t&#x3C;!-- scrollable content here -->\n&#x3C;/div>\n</code></pre>\n<p>You can now access:</p>\n<ul>\n<li>\n<p><code>scroll.x</code> and <code>scroll.y</code> — current scroll positions (reactive, get/set)</p>\n</li>\n<li>\n<p><code>scroll.directions</code> — active scroll directions</p>\n</li>\n<li>\n<p><code>scroll.arrived</code> — whether the scroll has reached each edge</p>\n</li>\n<li>\n<p><code>scroll.progress</code> — percentage that the user has scrolled on the x/y axis</p>\n</li>\n<li>\n<p><code>scroll.scrollTo(x, y)</code> — programmatic scroll</p>\n</li>\n<li>\n<p><code>scroll.scrollToTop()</code> and <code>scroll.scrollToBottom()</code> — helpers</p>\n</li>\n</ul>\n<h2>Options</h2>\n<p>You can configure <code>ScrollState</code> via the following options:</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>Option</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>element</code></td><td><code>MaybeGetter&#x3C;HTMLElement | Window | Document | null></code></td><td>The scroll container (required).</td></tr><tr><td><code>idle</code></td><td><code>MaybeGetter&#x3C;number | undefined></code></td><td>Debounce time (ms) after scroll ends. Default: <code>200</code>.</td></tr><tr><td><code>offset</code></td><td><code>{ top?, bottom?, left?, right? }</code></td><td>Pixel thresholds for \"arrived\" state detection. Default: <code>0</code> for all.</td></tr><tr><td><code>onScroll</code></td><td><code>(e: Event) => void</code></td><td>Callback for scroll events.</td></tr><tr><td><code>onStop</code></td><td><code>(e: Event) => void</code></td><td>Callback after scrolling stops.</td></tr><tr><td><code>eventListenerOptions</code></td><td><code>AddEventListenerOptions</code></td><td>Scroll listener options. Default: <code>{ passive: true, capture: false }</code>.</td></tr><tr><td><code>behavior</code></td><td><code>ScrollBehavior</code></td><td>Scroll behavior: <code>\"auto\"</code>, <code>\"smooth\"</code>, etc. Default: <code>\"auto\"</code>.</td></tr><tr><td><code>onError</code></td><td><code>(error: unknown) => void</code></td><td>Optional error handler. Default: <code>console.error</code>.</td></tr></tbody></table>\n<h2>Notes</h2>\n<ul>\n<li>\n<p>Both scroll position (<code>x</code>, <code>y</code>) and edge arrival state (<code>arrived</code>) are reactive values.</p>\n</li>\n<li>\n<p>You can programmatically change <code>scroll.x</code> and <code>scroll.y</code>, and the element will scroll\naccordingly.</p>\n</li>\n<li>\n<p>Layout direction and reverse flex settings are respected when calculating edge states.</p>\n</li>\n<li>\n<p>Debounced <code>onStop</code> is invoked after scrolling ends and the user is idle.</p>\n</li>\n</ul></demo>",
    "raw": "<script>\nimport Demo from '$lib/components/demos/scroll-state.svelte';\n</script>\n\n## Demo\n\n<Demo />\n\n## Overview\n\n`ScrollState` is a reactive utility that lets you:\n\n- Track scroll positions (`x` / `y`)\n- Detect scroll direction (`left`, `right`, `top`, `bottom`)\n- Determine if the user has scrolled to an edge (`arrived` state)\n- Perform programmatic scrolling (`scrollTo`, `scrollToTop`, `scrollToBottom`)\n- Listen to scroll and scroll-end events\n- Respect flex, RTL, and reverse layout modes\n\nInspired by [VueUse's `useScroll`](https://vueuse.org/useScroll), this utility is built for Svelte\nand works with DOM elements, the `window`, or `document`.\n\n## Usage\n\n```svelte\n<script lang=\"ts\">\n\timport { ScrollState } from \"runed\";\n\n\tlet el = $state<HTMLElement>();\n\n\tconst scroll = new ScrollState({\n\t\telement: () => el\n\t});\n</script>\n\n<div bind:this={el} style=\"overflow: auto; height: 200px;\">\n\t<!-- scrollable content here -->\n</div>\n```\n\nYou can now access:\n\n- `scroll.x` and `scroll.y` — current scroll positions (reactive, get/set)\n\n- `scroll.directions` — active scroll directions\n\n- `scroll.arrived` — whether the scroll has reached each edge\n\n- `scroll.progress` — percentage that the user has scrolled on the x/y axis\n\n- `scroll.scrollTo(x, y)` — programmatic scroll\n\n- `scroll.scrollToTop()` and `scroll.scrollToBottom()` — helpers\n\n## Options\n\nYou can configure `ScrollState` via the following options:\n\n| Option                 | Type                                                     | Description                                                            |\n| ---------------------- | -------------------------------------------------------- | ---------------------------------------------------------------------- |\n| `element`              | `MaybeGetter<HTMLElement \\| Window \\| Document \\| null>` | The scroll container (required).                                       |\n| `idle`                 | `MaybeGetter<number \\| undefined>`                       | Debounce time (ms) after scroll ends. Default: `200`.                  |\n| `offset`               | `{ top?, bottom?, left?, right? }`                       | Pixel thresholds for \"arrived\" state detection. Default: `0` for all.  |\n| `onScroll`             | `(e: Event) => void`                                     | Callback for scroll events.                                            |\n| `onStop`               | `(e: Event) => void`                                     | Callback after scrolling stops.                                        |\n| `eventListenerOptions` | `AddEventListenerOptions`                                | Scroll listener options. Default: `{ passive: true, capture: false }`. |\n| `behavior`             | `ScrollBehavior`                                         | Scroll behavior: `\"auto\"`, `\"smooth\"`, etc. Default: `\"auto\"`.         |\n| `onError`              | `(error: unknown) => void`                               | Optional error handler. Default: `console.error`.                      |\n\n## Notes\n\n- Both scroll position (`x`, `y`) and edge arrival state (`arrived`) are reactive values.\n\n- You can programmatically change `scroll.x` and `scroll.y`, and the element will scroll\n  accordingly.\n\n- Layout direction and reverse flex settings are respected when calculating edge states.\n\n- Debounced `onStop` is invoked after scrolling ends and the user is idle.",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Overview",
        "url": "#overview",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      },
      {
        "title": "Options",
        "url": "#options",
        "items": []
      },
      {
        "title": "Notes",
        "url": "#notes",
        "items": []
      }
    ],
    "category": "Elements",
    "slug": "utilities/scroll-state",
    "slugFull": "/utilities/scroll-state"
  },
  {
    "title": "StateHistory",
    "description": "Track state changes with undo/redo capabilities",
    "path": "utilities/state-history",
    "content": "<script>\nimport Demo from '$lib/components/demos/state-history.svelte';\n</script>\n<h2>Demo</h2>\n<demo>\n<h2>Usage</h2>\n<p><code>StateHistory</code> tracks a getter's return value, logging each change into an array. A setter is also\nrequired to use the <code>undo</code> and <code>redo</code> functions.</p>\n<pre><code class=\"language-ts\">import { StateHistory } from \"runed\";\n\nlet count = $state(0);\nconst history = new StateHistory(() => count, (c) => (count = c));\nhistory.log[0]; // { snapshot: 0, timestamp: ... }\n</code></pre>\n<p>Besides <code>log</code>, the returned object contains <code>undo</code> and <code>redo</code> functionality.</p>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { StateHistory } from \"runed\";\n\n\tlet count = $state(0);\n\tconst history = new StateHistory(() => count, (c) => (count = c));\n&#x3C;/script>\n\n&#x3C;p>{count}&#x3C;/p>\n\n&#x3C;button onclick={() => count++}>Increment&#x3C;/button>\n&#x3C;button onclick={() => count--}>Decrement&#x3C;/button>\n\n&#x3C;button disabled={!history.canUndo} onclick={history.undo}>Undo&#x3C;/button>\n&#x3C;button disabled={!history.canRedo} onclick={history.redo}>Redo&#x3C;/button>\n</code></pre></demo>",
    "raw": "<script>\nimport Demo from '$lib/components/demos/state-history.svelte';\n</script>\n\n## Demo\n\n<Demo />\n\n## Usage\n\n`StateHistory` tracks a getter's return value, logging each change into an array. A setter is also\nrequired to use the `undo` and `redo` functions.\n\n<!-- prettier-ignore -->\n```ts\nimport { StateHistory } from \"runed\";\n\nlet count = $state(0);\nconst history = new StateHistory(() => count, (c) => (count = c));\nhistory.log[0]; // { snapshot: 0, timestamp: ... }\n```\n\nBesides `log`, the returned object contains `undo` and `redo` functionality.\n\n<!-- prettier-ignore -->\n```svelte\n<script lang=\"ts\">\n\timport { StateHistory } from \"runed\";\n\n\tlet count = $state(0);\n\tconst history = new StateHistory(() => count, (c) => (count = c));\n</script>\n\n<p>{count}</p>\n\n<button onclick={() => count++}>Increment</button>\n<button onclick={() => count--}>Decrement</button>\n\n<button disabled={!history.canUndo} onclick={history.undo}>Undo</button>\n<button disabled={!history.canRedo} onclick={history.redo}>Redo</button>\n```",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      }
    ],
    "category": "State",
    "slug": "utilities/state-history",
    "slugFull": "/utilities/state-history"
  },
  {
    "title": "TextareaAutosize",
    "description": "Automatically adjust a textarea's height based on its content.",
    "path": "utilities/textarea-autosize",
    "content": "<script>\nimport Demo from '$lib/components/demos/textarea-autosize.svelte';\n</script>\n<h2>Demo</h2>\n<demo>\n<h2>Overview</h2>\n<p><code>TextareaAutosize</code> is a utility that makes <code>&#x3C;textarea></code> elements grow or shrink automatically based\non their content, without causing layout shifts. It:</p>\n<ul>\n<li>Mirrors the actual textarea off-screen for accurate measurement</li>\n<li>Syncs dimensions when the content, width, or element changes</li>\n<li>Prevents overflow until a maximum height (if configured)</li>\n<li>Supports both reactive state and static values</li>\n</ul>\n<h2>Usage</h2>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { TextareaAutosize } from \"runed\";\n\n\tlet el = $state&#x3C;HTMLTextAreaElement>(null!);\n\tlet value = $state(\"\");\n\n\tnew TextareaAutosize({\n\t\telement: () => el,\n\t\tinput: () => value\n\t});\n&#x3C;/script>\n\n&#x3C;textarea bind:this={el} bind:value>&#x3C;/textarea>\n</code></pre>\n<p>As you type, the textarea will automatically resize vertically to fit the content.</p>\n<h2>Options</h2>\n<p>You can customize behavior via the following options:</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>Option</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>element</code></td><td><code>Getter&#x3C;HTMLElement | undefined></code></td><td>The target textarea (required).</td></tr><tr><td><code>input</code></td><td><code>Getter&#x3C;string></code></td><td>Reactive input value (required).</td></tr><tr><td><code>onResize</code></td><td><code>() => void</code></td><td>Called whenever the height is updated.</td></tr><tr><td><code>styleProp</code></td><td><code>\"height\"</code> | <code>\"minHeight\"</code></td><td>CSS property to control size. <code>\"height\"</code> resizes both ways. <code>\"minHeight\"</code> grows only. Default: <code>\"height\"</code>.</td></tr><tr><td><code>maxHeight</code></td><td><code>number</code></td><td>Maximum height in pixels before scroll appears. Default: unlimited.</td></tr></tbody></table>\n<h2>Behavior</h2>\n<p>Internally, <code>TextareaAutosize</code>:</p>\n<ul>\n<li>Creates an invisible, off-screen <code>&#x3C;textarea></code> clone</li>\n<li>Copies computed styles from the actual textarea</li>\n<li>Measures scroll height of the clone to determine needed height</li>\n<li>Applies the height (or <code>minHeight</code>) to the real textarea</li>\n<li>Recalculates on content changes, element resizes, and width changes</li>\n</ul>\n<h2>Examples</h2>\n<h3>Grow-only Behavior</h3>\n<pre><code class=\"language-ts\">new TextareaAutosize({\n\telement: () => el,\n\tinput: () => value,\n\tstyleProp: \"minHeight\"\n});\n</code></pre>\n<p>This lets the textarea expand as needed, but won't shrink smaller than its current size.</p></demo>",
    "raw": "<script>\nimport Demo from '$lib/components/demos/textarea-autosize.svelte';\n</script>\n\n## Demo\n\n<Demo />\n\n## Overview\n\n`TextareaAutosize` is a utility that makes `<textarea>` elements grow or shrink automatically based\non their content, without causing layout shifts. It:\n\n- Mirrors the actual textarea off-screen for accurate measurement\n- Syncs dimensions when the content, width, or element changes\n- Prevents overflow until a maximum height (if configured)\n- Supports both reactive state and static values\n\n## Usage\n\n```svelte\n<script lang=\"ts\">\n\timport { TextareaAutosize } from \"runed\";\n\n\tlet el = $state<HTMLTextAreaElement>(null!);\n\tlet value = $state(\"\");\n\n\tnew TextareaAutosize({\n\t\telement: () => el,\n\t\tinput: () => value\n\t});\n</script>\n\n<textarea bind:this={el} bind:value></textarea>\n```\n\nAs you type, the textarea will automatically resize vertically to fit the content.\n\n## Options\n\nYou can customize behavior via the following options:\n\n| Option      | Type                               | Description                                                                                                |\n| ----------- | ---------------------------------- | ---------------------------------------------------------------------------------------------------------- |\n| `element`   | `Getter<HTMLElement \\| undefined>` | The target textarea (required).                                                                            |\n| `input`     | `Getter<string>`                   | Reactive input value (required).                                                                           |\n| `onResize`  | `() => void`                       | Called whenever the height is updated.                                                                     |\n| `styleProp` | `\"height\"` \\| `\"minHeight\"`        | CSS property to control size. `\"height\"` resizes both ways. `\"minHeight\"` grows only. Default: `\"height\"`. |\n| `maxHeight` | `number`                           | Maximum height in pixels before scroll appears. Default: unlimited.                                        |\n\n## Behavior\n\nInternally, `TextareaAutosize`:\n\n- Creates an invisible, off-screen `<textarea>` clone\n- Copies computed styles from the actual textarea\n- Measures scroll height of the clone to determine needed height\n- Applies the height (or `minHeight`) to the real textarea\n- Recalculates on content changes, element resizes, and width changes\n\n## Examples\n\n### Grow-only Behavior\n\n```ts\nnew TextareaAutosize({\n\telement: () => el,\n\tinput: () => value,\n\tstyleProp: \"minHeight\"\n});\n```\n\nThis lets the textarea expand as needed, but won't shrink smaller than its current size.",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Overview",
        "url": "#overview",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      },
      {
        "title": "Options",
        "url": "#options",
        "items": []
      },
      {
        "title": "Behavior",
        "url": "#behavior",
        "items": []
      },
      {
        "title": "Examples",
        "url": "#examples",
        "items": [
          {
            "title": "Grow-only Behavior",
            "url": "#grow-only-behavior",
            "items": []
          }
        ]
      }
    ],
    "category": "Elements",
    "slug": "utilities/textarea-autosize",
    "slugFull": "/utilities/textarea-autosize"
  },
  {
    "title": "Throttled",
    "description": "A wrapper over `useThrottle` that returns a throttled state.",
    "path": "utilities/throttled",
    "content": "<script>\nimport Demo from '$lib/components/demos/throttled.svelte';\n</script>\n<h2>Demo</h2>\n<demo>\n<h2>Usage</h2>\n<p>This is a simple wrapper over <a href=\"https://runed.dev/docs/utilities/use-throttle\"><code>useThrottle</code></a> that\nreturns a throttled state.</p>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { Throttled } from \"runed\";\n\n\tlet search = $state(\"\");\n\tconst throttled = new Throttled(() => search, 500);\n&#x3C;/script>\n\n&#x3C;div>\n\t&#x3C;input bind:value={search} />\n\t&#x3C;p>You searched for: &#x3C;b>{throttled.current}&#x3C;/b>&#x3C;/p>\n&#x3C;/div>\n</code></pre>\n<p>You may cancel the pending update, or set a new value immediately. Setting immediately also cancels\nany pending updates.</p>\n<pre><code class=\"language-ts\">let count = $state(0);\nconst throttled = new Throttled(() => count, 500);\ncount = 1;\nthrottled.cancel();\n// after a while...\nconsole.log(throttled.current); // Still 0!\n\ncount = 2;\nconsole.log(throttled.current); // Still 0!\nthrottled.setImmediately(count);\nconsole.log(throttled.current); // 2\n</code></pre></demo>",
    "raw": "<script>\nimport Demo from '$lib/components/demos/throttled.svelte';\n</script>\n\n## Demo\n\n<Demo />\n\n## Usage\n\nThis is a simple wrapper over [`useThrottle`](https://runed.dev/docs/utilities/use-throttle) that\nreturns a throttled state.\n\n```svelte\n<script lang=\"ts\">\n\timport { Throttled } from \"runed\";\n\n\tlet search = $state(\"\");\n\tconst throttled = new Throttled(() => search, 500);\n</script>\n\n<div>\n\t<input bind:value={search} />\n\t<p>You searched for: <b>{throttled.current}</b></p>\n</div>\n```\n\nYou may cancel the pending update, or set a new value immediately. Setting immediately also cancels\nany pending updates.\n\n```ts\nlet count = $state(0);\nconst throttled = new Throttled(() => count, 500);\ncount = 1;\nthrottled.cancel();\n// after a while...\nconsole.log(throttled.current); // Still 0!\n\ncount = 2;\nconsole.log(throttled.current); // Still 0!\nthrottled.setImmediately(count);\nconsole.log(throttled.current); // 2\n```",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      }
    ],
    "category": "State",
    "slug": "utilities/throttled",
    "slugFull": "/utilities/throttled"
  },
  {
    "title": "useDebounce",
    "description": "A higher-order function that debounces the execution of a function.",
    "path": "utilities/use-debounce",
    "content": "<script>\n\timport Demo from '$lib/components/demos/use-debounce.svelte';\n</script>\n<p><code>useDebounce</code> is a utility function that creates a debounced version of a callback function.\nDebouncing prevents a function from being called too frequently by delaying its execution until\nafter a specified duration of inactivity.</p>\n<h2>Demo</h2>\n<demo>\n<h2>Usage</h2>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { useDebounce } from \"runed\";\n\n\tlet count = $state(0);\n\tlet logged = $state(\"\");\n\tlet isFirstTime = $state(true);\n\tlet debounceDuration = $state(1000);\n\n\tconst logCount = useDebounce(\n\t\t() => {\n\t\t\tif (isFirstTime) {\n\t\t\t\tisFirstTime = false;\n\t\t\t\tlogged = `You pressed the button ${count} times!`;\n\t\t\t} else {\n\t\t\t\tlogged = `You pressed the button ${count} times since last time!`;\n\t\t\t}\n\t\t\tcount = 0;\n\t\t},\n\t\t() => debounceDuration\n\t);\n\n\tfunction ding() {\n\t\tcount++;\n\t\tlogCount();\n\t}\n&#x3C;/script>\n\n&#x3C;input type=\"number\" bind:value={debounceDuration} />\n&#x3C;button onclick={ding}>DING DING DING&#x3C;/button>\n&#x3C;button onclick={logCount.runScheduledNow} disabled={!logCount.pending}>Run now&#x3C;/button>\n&#x3C;button onclick={logCount.cancel} disabled={!logCount.pending}>Cancel message&#x3C;/button>\n&#x3C;p>{logged || \"Press the button!\"}&#x3C;/p>\n</code></pre></demo>",
    "raw": "<script>\n\timport Demo from '$lib/components/demos/use-debounce.svelte';\n</script>\n\n`useDebounce` is a utility function that creates a debounced version of a callback function.\nDebouncing prevents a function from being called too frequently by delaying its execution until\nafter a specified duration of inactivity.\n\n## Demo\n\n<Demo />\n\n## Usage\n\n```svelte\n<script lang=\"ts\">\n\timport { useDebounce } from \"runed\";\n\n\tlet count = $state(0);\n\tlet logged = $state(\"\");\n\tlet isFirstTime = $state(true);\n\tlet debounceDuration = $state(1000);\n\n\tconst logCount = useDebounce(\n\t\t() => {\n\t\t\tif (isFirstTime) {\n\t\t\t\tisFirstTime = false;\n\t\t\t\tlogged = `You pressed the button ${count} times!`;\n\t\t\t} else {\n\t\t\t\tlogged = `You pressed the button ${count} times since last time!`;\n\t\t\t}\n\t\t\tcount = 0;\n\t\t},\n\t\t() => debounceDuration\n\t);\n\n\tfunction ding() {\n\t\tcount++;\n\t\tlogCount();\n\t}\n</script>\n\n<input type=\"number\" bind:value={debounceDuration} />\n<button onclick={ding}>DING DING DING</button>\n<button onclick={logCount.runScheduledNow} disabled={!logCount.pending}>Run now</button>\n<button onclick={logCount.cancel} disabled={!logCount.pending}>Cancel message</button>\n<p>{logged || \"Press the button!\"}</p>\n```",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      }
    ],
    "category": "Utilities",
    "slug": "utilities/use-debounce",
    "slugFull": "/utilities/use-debounce"
  },
  {
    "title": "useEventListener",
    "description": "A function that attaches an automatically disposed event listener.",
    "path": "utilities/use-event-listener",
    "content": "<script>\nimport Demo from '$lib/components/demos/use-event-listener.svelte';\n</script>\n<h2>Demo</h2>\n<demo>\n<h2>Usage</h2>\n<p>The <code>useEventListener</code> function is particularly useful for attaching event listeners to elements you\ndon't directly control. For instance, if you need to listen for events on the document body or\nwindow and can't use <code>&#x3C;svelte:body /></code>, or if you receive an element reference from a parent\ncomponent.</p>\n<h3>Example: Tracking Clicks on the Document</h3>\n<pre><code class=\"language-ts\">// ClickLogger.ts\nimport { useEventListener } from \"runed\";\n\nexport class ClickLogger {\n\t#clicks = $state(0);\n\n\tconstructor() {\n\t\tuseEventListener(\n\t\t\t() => document.body,\n\t\t\t\"click\",\n\t\t\t() => this.#clicks++\n\t\t);\n\t}\n\n\tget clicks() {\n\t\treturn this.#clicks;\n\t}\n}\n</code></pre>\n<p>This <code>ClickLogger</code> class tracks the number of clicks on the document body using the\n<code>useEventListener</code> function. Each time a click occurs, the internal counter increments.</p>\n<h3>Svelte Component Usage</h3>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { ClickLogger } from \"./ClickLogger.ts\";\n\n\tconst logger = new ClickLogger();\n&#x3C;/script>\n\n&#x3C;p>\n\tYou've clicked the document {logger.clicks}\n\t{logger.clicks === 1 ? \"time\" : \"times\"}\n&#x3C;/p>\n</code></pre>\n<p>In the component above, we create an instance of the <code>ClickLogger</code> class to monitor clicks on the\ndocument. The displayed text updates dynamically based on the recorded click count.</p>\n<h3>Key Points</h3>\n<ul>\n<li><strong>Automatic Cleanup:</strong> The event listener is removed automatically when the component is destroyed\nor when the element reference changes.</li>\n<li><strong>Lazy Initialization:</strong> The target element can be defined using a function, enabling flexible and\ndynamic behavior.</li>\n<li><strong>Convenient for Global Listeners:</strong> Ideal for scenarios where attaching event listeners directly\nto the DOM elements is cumbersome or impractical.</li>\n</ul></demo>",
    "raw": "<script>\nimport Demo from '$lib/components/demos/use-event-listener.svelte';\n</script>\n\n## Demo\n\n<Demo />\n\n## Usage\n\nThe `useEventListener` function is particularly useful for attaching event listeners to elements you\ndon't directly control. For instance, if you need to listen for events on the document body or\nwindow and can't use `<svelte:body />`, or if you receive an element reference from a parent\ncomponent.\n\n### Example: Tracking Clicks on the Document\n\n```ts\n// ClickLogger.ts\nimport { useEventListener } from \"runed\";\n\nexport class ClickLogger {\n\t#clicks = $state(0);\n\n\tconstructor() {\n\t\tuseEventListener(\n\t\t\t() => document.body,\n\t\t\t\"click\",\n\t\t\t() => this.#clicks++\n\t\t);\n\t}\n\n\tget clicks() {\n\t\treturn this.#clicks;\n\t}\n}\n```\n\nThis `ClickLogger` class tracks the number of clicks on the document body using the\n`useEventListener` function. Each time a click occurs, the internal counter increments.\n\n### Svelte Component Usage\n\n```svelte\n<script lang=\"ts\">\n\timport { ClickLogger } from \"./ClickLogger.ts\";\n\n\tconst logger = new ClickLogger();\n</script>\n\n<p>\n\tYou've clicked the document {logger.clicks}\n\t{logger.clicks === 1 ? \"time\" : \"times\"}\n</p>\n```\n\nIn the component above, we create an instance of the `ClickLogger` class to monitor clicks on the\ndocument. The displayed text updates dynamically based on the recorded click count.\n\n### Key Points\n\n- **Automatic Cleanup:** The event listener is removed automatically when the component is destroyed\n  or when the element reference changes.\n- **Lazy Initialization:** The target element can be defined using a function, enabling flexible and\n  dynamic behavior.\n- **Convenient for Global Listeners:** Ideal for scenarios where attaching event listeners directly\n  to the DOM elements is cumbersome or impractical.",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": [
          {
            "title": "Example: Tracking Clicks on the Document",
            "url": "#example-tracking-clicks-on-the-document",
            "items": []
          },
          {
            "title": "Svelte Component Usage",
            "url": "#svelte-component-usage",
            "items": []
          },
          {
            "title": "Key Points",
            "url": "#key-points",
            "items": []
          }
        ]
      }
    ],
    "category": "Browser",
    "slug": "utilities/use-event-listener",
    "slugFull": "/utilities/use-event-listener"
  },
  {
    "title": "useGeolocation",
    "description": "Reactive access to the browser's Geolocation API.",
    "path": "utilities/use-geolocation",
    "content": "<script>\nimport Demo from '$lib/components/demos/use-geolocation.svelte';\n</script>\n<p><code>useGeolocation</code> is a reactive wrapper around the browser's\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API\">Geolocation API</a>.</p>\n<h2>Demo</h2>\n<demo>\n<h2>Usage</h2>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { useGeolocation } from \"runed\";\n\n\tconst location = useGeolocation();\n&#x3C;/script>\n\n&#x3C;pre>Coords: {JSON.stringify(location.position.coords, null, 2)}&#x3C;/pre>\n&#x3C;pre>Located at: {location.position.timestamp}&#x3C;/pre>\n&#x3C;pre>Error: {JSON.stringify(location.error, null, 2)}&#x3C;/pre>\n&#x3C;pre>Is Supported: {location.isSupported}&#x3C;/pre>\n&#x3C;button onclick={location.pause} disabled={location.isPaused}>Pause&#x3C;/button>\n&#x3C;button onclick={location.resume} disabled={!location.isPaused}>Resume&#x3C;/button>\n</code></pre>\n<h2>Type Definitions</h2>\n<pre><code class=\"language-ts\">type UseGeolocationOptions = Partial&#x3C;PositionOptions> &#x26; {\n\t/**\n\t * Whether to start the watcher immediately upon creation.\n\t * If set to `false`, the watcher will only start tracking the position when `resume()` is called.\n\t *\n\t * @defaultValue true\n\t */\n\timmediate?: boolean;\n};\n\ntype UseGeolocationReturn = {\n\treadonly isSupported: boolean;\n\treadonly position: Omit&#x3C;GeolocationPosition, \"toJSON\">;\n\treadonly error: GeolocationPositionError | null;\n\treadonly isPaused: boolean;\n\tpause: () => void;\n\tresume: () => void;\n};\n</code></pre></demo>",
    "raw": "<script>\nimport Demo from '$lib/components/demos/use-geolocation.svelte';\n</script>\n\n`useGeolocation` is a reactive wrapper around the browser's\n[Geolocation API](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API).\n\n## Demo\n\n<Demo />\n\n## Usage\n\n```svelte\n<script lang=\"ts\">\n\timport { useGeolocation } from \"runed\";\n\n\tconst location = useGeolocation();\n</script>\n\n<pre>Coords: {JSON.stringify(location.position.coords, null, 2)}</pre>\n<pre>Located at: {location.position.timestamp}</pre>\n<pre>Error: {JSON.stringify(location.error, null, 2)}</pre>\n<pre>Is Supported: {location.isSupported}</pre>\n<button onclick={location.pause} disabled={location.isPaused}>Pause</button>\n<button onclick={location.resume} disabled={!location.isPaused}>Resume</button>\n```\n\n## Type Definitions\n\n```ts\ntype UseGeolocationOptions = Partial<PositionOptions> & {\n\t/**\n\t * Whether to start the watcher immediately upon creation.\n\t * If set to `false`, the watcher will only start tracking the position when `resume()` is called.\n\t *\n\t * @defaultValue true\n\t */\n\timmediate?: boolean;\n};\n\ntype UseGeolocationReturn = {\n\treadonly isSupported: boolean;\n\treadonly position: Omit<GeolocationPosition, \"toJSON\">;\n\treadonly error: GeolocationPositionError | null;\n\treadonly isPaused: boolean;\n\tpause: () => void;\n\tresume: () => void;\n};\n```",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      },
      {
        "title": "Type Definitions",
        "url": "#type-definitions",
        "items": []
      }
    ],
    "category": "Sensors",
    "slug": "utilities/use-geolocation",
    "slugFull": "/utilities/use-geolocation"
  },
  {
    "title": "useIntersectionObserver",
    "description": "Watch for intersection changes of a target element.",
    "path": "utilities/use-intersection-observer",
    "content": "<script>\nimport Demo from '$lib/components/demos/use-intersection-observer.svelte';\nimport { Callout } from '@svecodocs/kit'\n</script>\n<h2>Demo</h2>\n<demo>\n<h2>Usage</h2>\n<p>With a reference to an element, you can use the <code>useIntersectionObserver</code> utility to watch for\nintersection changes of the target element.</p>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { useIntersectionObserver } from \"runed\";\n\n\tlet target = $state&#x3C;HTMLElement | null>(null);\n\tlet root = $state&#x3C;HTMLElement | null>(null);\n\n\tlet isIntersecting = $state(false);\n\n\tuseIntersectionObserver(\n\t\t() => target,\n\t\t(entries) => {\n\t\t\tconst entry = entries[0];\n\t\t\tif (!entry) return;\n\t\t\tisIntersecting = entry.isIntersecting;\n\t\t},\n\t\t{ root: () => root }\n\t);\n&#x3C;/script>\n\n&#x3C;div bind:this={root}>\n\t&#x3C;div bind:this={target}>\n\t\t{#if isIntersecting}\n\t\t\t&#x3C;div>Target is intersecting&#x3C;/div>\n\t\t{:else}\n\t\t\t&#x3C;div>Target is not intersecting&#x3C;/div>\n\t\t{/if}\n\t&#x3C;/div>\n&#x3C;/div>\n</code></pre>\n<h3>Pause</h3>\n<p>You can pause the intersection observer at any point by calling the <code>pause</code> method.</p>\n<pre><code class=\"language-ts\">const observer = useIntersectionObserver(/* ... */);\n\nobserver.pause();\n</code></pre>\n<h3>Resume</h3>\n<p>You can resume the intersection observer at any point by calling the <code>resume</code> method.</p>\n<pre><code class=\"language-ts\">const observer = useIntersectionObserver(/* ... */);\n\nobserver.resume();\n</code></pre>\n<h3>Stop</h3>\n<p>You can stop the intersection observer at any point by calling the <code>stop</code> method.</p>\n<pre><code class=\"language-ts\">const observer = useIntersectionObserver(/* ... */);\n\nobserver.stop();\n</code></pre>\n<h3>isActive</h3>\n<p>You can check if the intersection observer is active by checking the <code>isActive</code> property.</p>\n<callout type=\"warning\">\n<p>This property cannot be destructured as it is a getter. You must access it directly from the\nobserver.</p>\n</callout>\n<pre><code class=\"language-ts\">const observer = useIntersectionObserver(/* ... */);\n\nif (observer.isActive) {\n\t// do something\n}\n</code></pre></demo>",
    "raw": "<script>\nimport Demo from '$lib/components/demos/use-intersection-observer.svelte';\nimport { Callout } from '@svecodocs/kit'\n</script>\n\n## Demo\n\n<Demo />\n\n## Usage\n\nWith a reference to an element, you can use the `useIntersectionObserver` utility to watch for\nintersection changes of the target element.\n\n```svelte\n<script lang=\"ts\">\n\timport { useIntersectionObserver } from \"runed\";\n\n\tlet target = $state<HTMLElement | null>(null);\n\tlet root = $state<HTMLElement | null>(null);\n\n\tlet isIntersecting = $state(false);\n\n\tuseIntersectionObserver(\n\t\t() => target,\n\t\t(entries) => {\n\t\t\tconst entry = entries[0];\n\t\t\tif (!entry) return;\n\t\t\tisIntersecting = entry.isIntersecting;\n\t\t},\n\t\t{ root: () => root }\n\t);\n</script>\n\n<div bind:this={root}>\n\t<div bind:this={target}>\n\t\t{#if isIntersecting}\n\t\t\t<div>Target is intersecting</div>\n\t\t{:else}\n\t\t\t<div>Target is not intersecting</div>\n\t\t{/if}\n\t</div>\n</div>\n```\n\n### Pause\n\nYou can pause the intersection observer at any point by calling the `pause` method.\n\n```ts\nconst observer = useIntersectionObserver(/* ... */);\n\nobserver.pause();\n```\n\n### Resume\n\nYou can resume the intersection observer at any point by calling the `resume` method.\n\n```ts\nconst observer = useIntersectionObserver(/* ... */);\n\nobserver.resume();\n```\n\n### Stop\n\nYou can stop the intersection observer at any point by calling the `stop` method.\n\n```ts\nconst observer = useIntersectionObserver(/* ... */);\n\nobserver.stop();\n```\n\n### isActive\n\nYou can check if the intersection observer is active by checking the `isActive` property.\n\n<Callout type=\"warning\">\n\nThis property cannot be destructured as it is a getter. You must access it directly from the\nobserver.\n\n</Callout>\n\n```ts\nconst observer = useIntersectionObserver(/* ... */);\n\nif (observer.isActive) {\n\t// do something\n}\n```",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": [
          {
            "title": "Pause",
            "url": "#pause",
            "items": []
          },
          {
            "title": "Resume",
            "url": "#resume",
            "items": []
          },
          {
            "title": "Stop",
            "url": "#stop",
            "items": []
          },
          {
            "title": "isActive",
            "url": "#isactive",
            "items": []
          }
        ]
      }
    ],
    "category": "Elements",
    "slug": "utilities/use-intersection-observer",
    "slugFull": "/utilities/use-intersection-observer"
  },
  {
    "title": "useMutationObserver",
    "description": "Observe changes in an element",
    "path": "utilities/use-mutation-observer",
    "content": "<script>\nimport Demo from '$lib/components/demos/use-mutation-observer.svelte';\n</script>\n<h2>Demo</h2>\n<demo>\n<h2>Usage</h2>\n<p>With a reference to an element, you can use the <code>useMutationObserver</code> hook to observe changes in the\nelement.</p>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { useMutationObserver } from \"runed\";\n\n\tlet el = $state&#x3C;HTMLElement | null>(null);\n\tconst messages = $state&#x3C;string[]>([]);\n\tlet className = $state(\"\");\n\tlet style = $state(\"\");\n\n\tuseMutationObserver(\n\t\t() => el,\n\t\t(mutations) => {\n\t\t\tconst mutation = mutations[0];\n\t\t\tif (!mutation) return;\n\n\t\t\tmessages.push(mutation.attributeName!);\n\t\t},\n\t\t{ attributes: true }\n\t);\n\n\tsetTimeout(() => {\n\t\tclassName = \"text-brand\";\n\t}, 1000);\n\n\tsetTimeout(() => {\n\t\tstyle = \"font-style: italic;\";\n\t}, 1500);\n&#x3C;/script>\n\n&#x3C;div bind:this={el} class={className} {style}>\n\t{#each messages as text}\n\t\t&#x3C;div>\n\t\t\tMutation Attribute: {text}\n\t\t&#x3C;/div>\n\t{:else}\n\t\t&#x3C;div>No mutations yet&#x3C;/div>\n\t{/each}\n&#x3C;/div>\n</code></pre>\n<p>You can stop the mutation observer at any point by calling the <code>stop</code> method.</p>\n<pre><code class=\"language-ts\">const { stop } = useMutationObserver(/* ... */);\nstop();\n</code></pre></demo>",
    "raw": "<script>\nimport Demo from '$lib/components/demos/use-mutation-observer.svelte';\n</script>\n\n## Demo\n\n<Demo />\n\n## Usage\n\nWith a reference to an element, you can use the `useMutationObserver` hook to observe changes in the\nelement.\n\n```svelte\n<script lang=\"ts\">\n\timport { useMutationObserver } from \"runed\";\n\n\tlet el = $state<HTMLElement | null>(null);\n\tconst messages = $state<string[]>([]);\n\tlet className = $state(\"\");\n\tlet style = $state(\"\");\n\n\tuseMutationObserver(\n\t\t() => el,\n\t\t(mutations) => {\n\t\t\tconst mutation = mutations[0];\n\t\t\tif (!mutation) return;\n\n\t\t\tmessages.push(mutation.attributeName!);\n\t\t},\n\t\t{ attributes: true }\n\t);\n\n\tsetTimeout(() => {\n\t\tclassName = \"text-brand\";\n\t}, 1000);\n\n\tsetTimeout(() => {\n\t\tstyle = \"font-style: italic;\";\n\t}, 1500);\n</script>\n\n<div bind:this={el} class={className} {style}>\n\t{#each messages as text}\n\t\t<div>\n\t\t\tMutation Attribute: {text}\n\t\t</div>\n\t{:else}\n\t\t<div>No mutations yet</div>\n\t{/each}\n</div>\n```\n\nYou can stop the mutation observer at any point by calling the `stop` method.\n\n```ts\nconst { stop } = useMutationObserver(/* ... */);\nstop();\n```",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      }
    ],
    "category": "Elements",
    "slug": "utilities/use-mutation-observer",
    "slugFull": "/utilities/use-mutation-observer"
  },
  {
    "title": "useResizeObserver",
    "description": "Detects changes in the size of an element",
    "path": "utilities/use-resize-observer",
    "content": "<script>\nimport Demo from '$lib/components/demos/use-resize-observer.svelte';\n</script>\n<h2>Demo</h2>\n<demo>\n<h2>Usage</h2>\n<p>With a reference to an element, you can use the <code>useResizeObserver</code> utility to detect changes in the\nsize of an element.</p>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { useResizeObserver } from \"runed\";\n\n\tlet el = $state&#x3C;HTMLElement | null>(null);\n\tlet text = $state(\"\");\n\n\tuseResizeObserver(\n\t\t() => el,\n\t\t(entries) => {\n\t\t\tconst entry = entries[0];\n\t\t\tif (!entry) return;\n\n\t\t\tconst { width, height } = entry.contentRect;\n\t\t\ttext = `width: ${width};\\nheight: ${height};`;\n\t\t}\n\t);\n&#x3C;/script>\n\n&#x3C;textarea bind:this={el} readonly value={text}>&#x3C;/textarea>\n</code></pre>\n<p>You can stop the resize observer at any point by calling the <code>stop</code> method.</p>\n<pre><code class=\"language-ts\">const { stop } = useResizeObserver(/* ... */);\nstop();\n</code></pre></demo>",
    "raw": "<script>\nimport Demo from '$lib/components/demos/use-resize-observer.svelte';\n</script>\n\n## Demo\n\n<Demo />\n\n## Usage\n\nWith a reference to an element, you can use the `useResizeObserver` utility to detect changes in the\nsize of an element.\n\n```svelte\n<script lang=\"ts\">\n\timport { useResizeObserver } from \"runed\";\n\n\tlet el = $state<HTMLElement | null>(null);\n\tlet text = $state(\"\");\n\n\tuseResizeObserver(\n\t\t() => el,\n\t\t(entries) => {\n\t\t\tconst entry = entries[0];\n\t\t\tif (!entry) return;\n\n\t\t\tconst { width, height } = entry.contentRect;\n\t\t\ttext = `width: ${width};\\nheight: ${height};`;\n\t\t}\n\t);\n</script>\n\n<textarea bind:this={el} readonly value={text}></textarea>\n```\n\nYou can stop the resize observer at any point by calling the `stop` method.\n\n```ts\nconst { stop } = useResizeObserver(/* ... */);\nstop();\n```",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      }
    ],
    "category": "Elements",
    "slug": "utilities/use-resize-observer",
    "slugFull": "/utilities/use-resize-observer"
  },
  {
    "title": "useThrottle",
    "description": "A higher-order function that throttles the execution of a function.",
    "path": "utilities/use-throttle",
    "content": "<script>\n import Demo from '$lib/components/demos/use-throttle.svelte';\n</script>\n<h2>Demo</h2>\n<demo>\n<h2>Usage</h2>\n<pre><code class=\"language-svelte\">&#x3C;script lang=\"ts\">\n\timport { useThrottle, watch } from \"runed\";\n\n\tlet search = $state(\"\");\n\tlet throttledSearch = $state(\"\");\n\tlet durationMs = $state(1000);\n\n\tconst throttledUpdate = useThrottle(\n\t\t() => {\n\t\t\tthrottledSearch = search;\n\t\t},\n\t\t() => durationMs\n\t);\n&#x3C;/script>\n\n&#x3C;div>\n\t&#x3C;input\n\t\tbind:value={\n\t\t\t() => search,\n\t\t\t(v) => {\n\t\t\t\tsearch = v;\n\t\t\t\tthrottledUpdate();\n\t\t\t}\n\t\t} />\n\t&#x3C;p>You searched for: &#x3C;b>{throttledSearch}&#x3C;/b>&#x3C;/p>\n&#x3C;/div>\n</code></pre></demo>",
    "raw": "<script>\n import Demo from '$lib/components/demos/use-throttle.svelte';\n</script>\n\n## Demo\n\n<Demo />\n\n## Usage\n\n```svelte\n<script lang=\"ts\">\n\timport { useThrottle, watch } from \"runed\";\n\n\tlet search = $state(\"\");\n\tlet throttledSearch = $state(\"\");\n\tlet durationMs = $state(1000);\n\n\tconst throttledUpdate = useThrottle(\n\t\t() => {\n\t\t\tthrottledSearch = search;\n\t\t},\n\t\t() => durationMs\n\t);\n</script>\n\n<div>\n\t<input\n\t\tbind:value={\n\t\t\t() => search,\n\t\t\t(v) => {\n\t\t\t\tsearch = v;\n\t\t\t\tthrottledUpdate();\n\t\t\t}\n\t\t} />\n\t<p>You searched for: <b>{throttledSearch}</b></p>\n</div>\n```",
    "toc": [
      {
        "title": "Demo",
        "url": "#demo",
        "items": []
      },
      {
        "title": "Usage",
        "url": "#usage",
        "items": []
      }
    ],
    "category": "Utilities",
    "slug": "utilities/use-throttle",
    "slugFull": "/utilities/use-throttle"
  },
  {
    "title": "watch",
    "description": "Watch for changes and run a callback",
    "path": "utilities/watch",
    "content": "<p>Runes provide a handy way of running a callback when reactive values change:\n<a href=\"https://svelte.dev/docs/svelte/$effect\"><code>$effect</code></a>. It automatically detects when inner values\nchange, and re-runs the callback.</p>\n<p><code>$effect</code> is great, but sometimes you want to manually specify which values should trigger the\ncallback. Svelte provides an <code>untrack</code> function, allowing you to specify that a dependency\n<em>shouldn't</em> be tracked, but it doesn't provide a way to say that <em>only certain values</em> should be\ntracked.</p>\n<p><code>watch</code> does exactly that. It accepts a getter function, which returns the dependencies of the\neffect callback.</p>\n<h2>Usage</h2>\n<h3>watch</h3>\n<p>Runs a callback whenever one of the sources change.</p>\n<pre><code class=\"language-ts\">import { watch } from \"runed\";\n\nlet count = $state(0);\nwatch(() => count, () => {\n\tconsole.log(count);\n});\n</code></pre>\n<p>You can deeply watch an entire object using $state.snapshot().</p>\n<pre><code class=\"language-ts\">let user = $state({ name: 'bob', age: 20 });\nwatch(() => $state.snapshot(user), () => {\n\tconsole.log(`${user.name} is ${user.age} years old`);\n});\n</code></pre>\n<p>Or you can watch a specific deep value.</p>\n<pre><code class=\"language-ts\">let user = $state({ name: 'bob', age: 20 });\nwatch(() => user.age), () => {\n\tconsole.log(`User is now ${user.age} years old`);\n});\n</code></pre>\n<p>You can also send in an array of sources.</p>\n<pre><code class=\"language-ts\">let age = $state(20);\nlet name = $state(\"bob\");\nwatch([() => age, () => name], ([age, name], [prevAge, prevName]) => {\n\t// ...\n});\n</code></pre>\n<p>The callback receives two arguments: The current value of the sources, and the previous value.</p>\n<pre><code class=\"language-ts\">let count = $state(0);\nwatch(() => count, (curr, prev) => {\n\tconsole.log(`count is ${curr}, was ${prev}`);\n});\n</code></pre>\n<p><code>watch</code> also accepts an <code>options</code> object.</p>\n<pre><code class=\"language-ts\">watch(sources, callback, {\n\t// First run will only happen after sources change when set to true.\n\t// By default, its false.\n\tlazy: true\n});\n</code></pre>\n<h3>watch.pre</h3>\n<p><code>watch.pre</code> is similar to <code>watch</code>, but it uses\n<a href=\"https://svelte.dev/docs/svelte/$effect#$effect.pre\"><code>$effect.pre</code></a> under the hood.</p>\n<h3>watchOnce</h3>\n<p>In case you want to run the callback only once, you can use <code>watchOnce</code> and <code>watchOnce.pre</code>. It\nfunctions identically to the <code>watch</code> and <code>watch.pre</code> otherwise, but it does not accept any options\nobject.</p>",
    "raw": "Runes provide a handy way of running a callback when reactive values change:\n[`$effect`](https://svelte.dev/docs/svelte/$effect). It automatically detects when inner values\nchange, and re-runs the callback.\n\n`$effect` is great, but sometimes you want to manually specify which values should trigger the\ncallback. Svelte provides an `untrack` function, allowing you to specify that a dependency\n_shouldn't_ be tracked, but it doesn't provide a way to say that _only certain values_ should be\ntracked.\n\n`watch` does exactly that. It accepts a getter function, which returns the dependencies of the\neffect callback.\n\n## Usage\n\n### watch\n\nRuns a callback whenever one of the sources change.\n\n<!-- prettier-ignore -->\n```ts\nimport { watch } from \"runed\";\n\nlet count = $state(0);\nwatch(() => count, () => {\n\tconsole.log(count);\n});\n```\n\nYou can deeply watch an entire object using $state.snapshot().\n\n<!-- prettier-ignore -->\n```ts\nlet user = $state({ name: 'bob', age: 20 });\nwatch(() => $state.snapshot(user), () => {\n\tconsole.log(`${user.name} is ${user.age} years old`);\n});\n```\n\nOr you can watch a specific deep value.\n\n<!-- prettier-ignore -->\n```ts\nlet user = $state({ name: 'bob', age: 20 });\nwatch(() => user.age), () => {\n\tconsole.log(`User is now ${user.age} years old`);\n});\n```\n\nYou can also send in an array of sources.\n\n<!-- prettier-ignore -->\n```ts\nlet age = $state(20);\nlet name = $state(\"bob\");\nwatch([() => age, () => name], ([age, name], [prevAge, prevName]) => {\n\t// ...\n});\n```\n\nThe callback receives two arguments: The current value of the sources, and the previous value.\n\n<!-- prettier-ignore -->\n```ts\nlet count = $state(0);\nwatch(() => count, (curr, prev) => {\n\tconsole.log(`count is ${curr}, was ${prev}`);\n});\n```\n\n`watch` also accepts an `options` object.\n\n```ts\nwatch(sources, callback, {\n\t// First run will only happen after sources change when set to true.\n\t// By default, its false.\n\tlazy: true\n});\n```\n\n### watch.pre\n\n`watch.pre` is similar to `watch`, but it uses\n[`$effect.pre`](https://svelte.dev/docs/svelte/$effect#$effect.pre) under the hood.\n\n### watchOnce\n\nIn case you want to run the callback only once, you can use `watchOnce` and `watchOnce.pre`. It\nfunctions identically to the `watch` and `watch.pre` otherwise, but it does not accept any options\nobject.",
    "toc": [
      {
        "title": "Usage",
        "url": "#usage",
        "items": [
          {
            "title": "watch",
            "url": "#watch",
            "items": []
          },
          {
            "title": "watch.pre",
            "url": "#watchpre",
            "items": []
          },
          {
            "title": "watchOnce",
            "url": "#watchonce",
            "items": []
          }
        ]
      }
    ],
    "category": "Reactivity",
    "slug": "utilities/watch",
    "slugFull": "/utilities/watch"
  }
]